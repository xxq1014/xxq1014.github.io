<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jsonp解决跨域传输问题]]></title>
      <url>%2F2016%2F12%2F15%2Fjsonp%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 ####比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是http://example.com/data.php,那么a.html中的代码就可以这样： 我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。 ####因为是当做一个js文件来引入的，所以http://example.com/data.php返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的: ####最终那个页面输出的结果是: 所以通过http://example.com/data.php?callback=dosomething得到的js文件，就是我们之前定义的dosomething函数,并且它的参数就是我们需要的json数据，这样我们就跨域获得了我们需要的数据。 这样jsonp的原理就很清楚了，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 知道jsonp跨域的原理后我们就可以用js动态生成script标签来进行跨域操作了，而不用特意的手动的书写那些script标签。如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。 ####原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript干货之学习方向]]></title>
      <url>%2F2016%2F12%2F15%2Fjavascript%E5%B9%B2%E8%B4%A7%E4%B9%8B%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%90%91%2F</url>
      <content type="text"><![CDATA[本篇文章将javascript知识点从低到高分为基础，中级，高级3个部分，看看你知道多少： javascript的基础知识.知道基本的编程语法，比如循环，判断，try/catch 等等 .理解包括多种函数定义以及赋值的方式，包括匿名函数 .理解基本的命名空间，全局（window）空间以及对象空间（不包括闭包） .理解上下文的角色以及 this 变量的使用 .理解各种对象以及函数的初始化和声明方式 .理解 javascript 比较操作符，如&lt;, &gt;, ==, ===，以及对象和字符串比较的原理和对象映射 .理解对象属性和函数的数组索引，以及这和真实的数组之间的区别。 javascript的中级知识.理解定时器，以及它的工作原理，包括何时以及如何使用定时器来异步执行方法调用 .关于回调的深度支持，以及如何通过 call 和 apply 方法来控制上下文和函数参数传递 .理解 JSON 标记以及 eval 函数 .理解闭包以及他们如何影响你的代码效率 .AJAX 以及对象序列化 .javascript 高级知识点 .理解方法的 arguments 变量，包括如何使用它来通过 arguments.length 重载函数，以及通过 arguments.callee 来进行递归调用，需要注意使用这个特性有一定的危险性，因为 ECMAScript 5 的 Strict 模式不支持此功能，但 jQuery 和 Dojo 都用到了它。 .高级闭包比如 self-memoizing 函数，partially applied 函数，以及最可爱的 (function(){})() 调用。 .函数以及 HTML prototype，prototype chain，以及如何使用基本的javascript对象和函数（比如 Array）来简化代码。 .对象类型以及 instanceof 的使用 .正则表达式和表达式编译 .With 语句以及为什么不要使用它们 .最困难的部分，知道如果利用所有这些工具，并产生处干净，整洁，健壮，快速，可维护以及兼容不同浏览器的代码。 javascript的重点知识.如何高效的操作 Dom（添加，删除以及更新），还有如何通过使用 document fragments 这样的工具来最小化浏览器的 re-flows。 .跨浏览器的 DOM 元素属性提取（比如，style，position等等），jQuery 和 Dojo 都可以很好的完成这些工作，尽管如此，理解从 CSS 和 style 标签中提取属性的差异，以及如何计算 position 和 size 还是很重要的。 .跨浏览器的事件处理，绑定，反绑定，冒泡，以及如何取得期望的回调上下文。在一次，现成的框架也可以很好的处理这些事情，但是你应该对 IE 浏览器和 W3C 标准浏览器之间的不同有所了解。 .正则表达式选取 DOM 节点 .浏览器功能检测以及智能降级]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解display属性]]></title>
      <url>%2F2016%2F12%2F08%2Fdisplay%2F</url>
      <content type="text"><![CDATA[深入理解display属性前面的话display属性在网页布局中非常常见，但经常用到的仅仅是block、inline-block、inline和none等寥寥几个属性值，本文将详细介绍display属性的各个方面 定义display属性用于规定元素生成的框类型，影响显示方式 值: none 、 inline 、 block 、 inline-block 、 list-item 、 run-in 、 table 、 inline-table 、 table-row-group 、 table-header-group 、 table-footer-group 、 table-row 、 table-colume-group 、 table-column 、 table-cell 、 table-caption 、 inherit 初始值: inline 应用于: 所有元素 继承性: 无 [注意]IE7-浏览器不支持table类属性值及inherit 分类block【特征】 不设置宽度时，宽度撑满一行 独占一行 支持宽高 【标签】 &lt;address&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;blockquote&gt;、&lt;body&gt;、&lt;dd&gt;、&lt;details&gt;、&lt;div&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;fieldset&gt;、&lt;figcaption&gt;、&lt;figure&gt;、&lt;footer&gt;、&lt;form&gt;、&lt;h1&gt;、&lt;header&gt;、&lt;hgroup&gt;、&lt;hr&gt;、&lt;html&gt;、&lt;legend&gt;、&lt;menuitem&gt;、&lt;nav&gt;、&lt;ol&gt;、&lt;optgroup&gt;、&lt;option&gt;、&lt;p&gt;、&lt;section&gt;、&lt;summary&gt;、&lt;ul&gt; 【注意】 menuitem标签只有firefox支持 【不支持的样式】 vertical-align inline【特征】 内容撑开宽度 非独占一行 不支持宽高 代码换行被解析成空格 【标签】 &lt;a&gt;&lt;abbr&gt;&lt;area&gt;&lt;b&gt;&lt;bdi&gt;&lt;bdo&gt;&lt;br&gt;&lt;cite&gt;&lt;code&gt;&lt;del&gt;&lt;dfn&gt;&lt;em&gt;&lt;i&gt;&lt;ins&gt;&lt;kbd&gt;&lt;label&gt;&lt;map&gt;&lt;mark&gt;&lt;output&gt;&lt;pre&gt;&lt;q&gt;&lt;rp&gt;&lt;rt&gt;&lt;ruby&gt;&lt;s&gt;&lt;smap&gt;&lt;small&gt;&lt;span&gt;&lt;strong&gt;&lt;sub&gt;&lt;sup&gt;&lt;time&gt;&lt;u&gt;&lt;var&gt;&lt;wbr&gt; 【不支持的样式】 background-position clear clip height | max-height | min-height width | max-width | min-width overflow text-align text-indent text-overflow inline-block【特征】 不设置宽度时，内容撑开宽度 非独占一行 支持宽高 代码换行被解析成空格 【标签】 &lt;audio&gt;、&lt;button&gt;、&lt;canvas&gt;、&lt;embed&gt;、&lt;iframe&gt;、&lt;img&gt;、&lt;input&gt;、&lt;keygen&gt;、&lt;meter&gt;、&lt;object&gt;、&lt;progress&gt;、&lt;select&gt;、&lt;textarea&gt;、&lt;video&gt; 【不支持的样式】 clear 【IE兼容】 IE7-浏览器不支持给块级元素设置inline-block样式，解决方法如下：首先将其变成行内元素，使用具有行内元素的特性，然后触发haslayout，使其具有块级元素的特性，如此就可以模拟出inline-block的效果 12345div&#123; display:inline-block; *display: inline; zoom: 1;&#125; [注意] 关于inline-block元素底部空隙的问题移步到此 none【特征】 隐藏元素并脱离文档流 【标签】 &lt;base&gt;、&lt;link&gt;、&lt;meta&gt;、&lt;title&gt;、&lt;datalist&gt;、&lt;dialog&gt;、&lt;param&gt;、&lt;script&gt;、&lt;source&gt;、&lt;style&gt; list-item【特征】 不设置宽度时，宽度撑满一行 独占一行 支持宽高 run-in run-in是一个有意思的块/行内元素混合，可以使某些块级元素成为下一个元素的行内部分。如果一个元素生成run-in框，而且该框后面是一个块级框，那么该run-in元素将成为块级框开始处的一个行内框，run-in框格式化成另一个元素中的行内框，但它们仍从文档中的父元素继承属性 [注意]只有safari和IE8+支持 12&lt;h3 style=&quot;display:run-in&quot;&gt;run-in test&lt;/h3&gt;&lt;p&gt;paragraph&lt;/p&gt; 若run-in框后面不是块级框时，run-in框本身将成为块级框 12&lt;span style=&quot;display:run-in&quot;&gt;run-in test&lt;/span&gt;&lt;span&gt;paragraph&lt;/span&gt; 表格类元素123456789table&#123;display: table;&#125;thead&#123;display: table-header-group;&#125;tbody&#123;display: table-row-group;&#125;tfoot&#123;display: table-footer-group;&#125;tr&#123;display: table-row;&#125;td,th&#123;display: table-cell;&#125;col&#123;display: table-column;&#125;colgroup&#123;display: table-column-group;&#125;caption&#123;display: table-caption;&#125; 表格类元素的display共有以上几种，&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;&lt;tr&gt;&lt;col&gt;&lt;colgroup&gt;因为无法设置margin和padding用的较少，下面将着重介绍下&lt;table&gt;、&lt;td&gt;、&lt;th&gt;、&lt;caption&gt;这四个标签对应的display属性 table【特征】 不设置宽度时，宽度由内容撑开 独占一行 支持宽高 默认具有表格特征，可设置table-layout、border-collapse、border-spacing等表格专有属性 inline-table【特征】 不设置宽度时，宽度由内容撑开 非独占一行 支持宽高 默认具有表格特征，可设置table-layout、border-collapse、border-spacing等表格专有属性 table-cell【特征】 不设置宽度时，宽度由内容撑开 非独占一行 支持宽高 垂直对齐 同级等高 table-caption【特征】 不设置宽度时，宽度由内容撑开 独占一行 支持宽高 注意事项 如果一个元素是绝对定位元素，float的值设置为none，对于浮动元素或绝对定位元素，计算值由声明值确定 对于根元素，如果声明为值inline-table或table，都会得到计算值table，声明为none时则会得到同样的计算值none，所有其他display值都计算为block]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[为什么整个互联网行业都缺前端工程师？]]></title>
      <url>%2F2016%2F12%2F04%2FWeb%2F</url>
      <content type="text"><![CDATA[为什么整个互联网行业都缺前端工程师？本文来自 100offer 团队原创投稿，转载需授权。部分内容译自：Why can’t we find Front End developers?。 前端工程师的缺乏问题几乎蔓延到整个互联网行业，从刚起步的创业公司，到上市公司乃至巨头，这个问题都存在着。没错，优秀的前端工程师简直比大熊猫还稀少。 每天，100offer 的 HR 群都有人在吐槽招不到靠谱的前端工程师。实话说对这些需求，100offer 也无能为力：在供不应求的前端招聘市场上，优秀的前端工程师才是有话语权的那一方。 在国外，前端工程师一样是需求旺盛、供不应求的香饽饽。 举个例子，根据 indeed.com 抓取的数千家网站的职位显示：目前前端的热门岗位——「HTML5」是需求增长最快的开发岗位，在所有开发职位中排名第一，MongoDB 和 iOS 紧随其后位列第二、第三。 HTML5 可以说是最热门的前端岗位了，在 2010 年和 2014 年底有两次爆发性增长，现在在美国的岗位需求甚至超过了iOS。 市场上优秀的前端工程师相对较缺少，是一个世界性难题。 原因一：前端相对来说是一个新领域，当今的web需求要求更多的工程师供应可能很多人认为前端开发和 web 开发类似，而 web 开发已经有20多年的历史，所以前端并不是一个新领域。然而，前端工程师的概念中的「接口技术实现和用户体验作为一个专业的工作领域」，却无疑是很新的。大概几年前，前端开发的技术增长迅猛，如下图所示： 过去几年前端工程师的可视化增长趋势 by Google Trends 至少15年以前，web 的视觉设计和技术实现所需要的资源是平均分配的。随着网站的发展——网站不仅是一个登录页面，工程资源的需求越来越明显。人们开始专门学习网站专用的 JS、后端技术、UX、数据库，甚至系统设计。 今天，一个像 AirBnB/Facebook/Quora 的 Web 应用程序，投入的工程资源比设计资源多得多。换句话说，如今，做出网页的视觉设计比技术实现要更快，所以当今的web需求要求更多的工程师供应。 现在，一位合格的前端工程师，必须对视觉设计有兴趣（或者乐于做一个受虐狂▼）。 很显然，要处理大量的 Web 应用程序需求，技术任务就要进行分类，以便于多人同时处理网站请求。事实上现在已经不可能一个人快速地解决所有的技术细节了。 现在还有一类人是独自处理一个 Web 应用程序的所有问题，即「全栈工程师」，但是优秀的全栈工程师同样如大熊猫一般数量稀少。 现在，一个创业公司想要成功，几乎要覆盖一个 Web 应用程序的诸多技术方面：前端、后台、DBA、运营等。虽然已经有一些服务可以让企业购买登陆页面的前端模块和组件；但是如果你想要创造一些真正的 Web 应用程序，除了求助前端工程师，别无他法，就像你要创立一个品牌你也绕不开请一位设计师一样。 原因二：对前端，普遍存在巨大的误解，其实前端一点也不简单大多人都认为前端开发是一个「相对于其他技术来说更简单的技术」，在他们心中的前端工程师是这样工作的： 把 Photoshop 文件、图片或者线框放进一个网页； 偶尔设计 Photoshop 文件、图片或者线框； 用 JS 编程，为网页制作动画、过渡效果； 用 HTML 和 CSS 编程，确定网页的内容和形式。 事实上，前端工程师在做的是： 在设计师和工程师之间创建可视化的语言； 用可视化的设计，定义一组代表内容、品牌和功能的组件； 为 Web 应用程序的公约、框架、需求、可视化的语言和规格设定底线； 定义 Web 应用程序的设备、浏览器、屏幕、动画的范围； 开发一个质量保证指南来确保品牌忠诚度、代码质量、产品标准； 为 Web 应用程序设定适当的行距、字体、标题、图标、余粮、填充等等； 为 Web 应用程序设定多种分辨率的图像，设备为主的实体模型，同时维护设计指南； 用 account semantics, accessibility, SEO, schemas ，microformats 标记 Web 应用程序； 用一种友好的，消耗小的，设备和客户端感知的方式连接 API，获取内容； 开发客户端代码来显示流畅的动画、过渡、延迟加载、交互、应用工作流程，大多数时间用来考虑渐进增强和向后兼容的标准； 保证后台连接安全，采取跨地资源共享（CORS）的程序考虑，防止跨站点脚本（XSS）和跨站点请求伪造（CSRF） ； 最重要的是，尽管有严格的期限、利益相关者的要求，以及设备的限制，无论现在还是将来永远是「客户第一」。 为了实现上述目标，前端工程师采用了从可视化到编程的多种工具 ，甚至有时要照顾市场、 UX 到内容等等。 原因三：大量糟糕前端工程师的存在，扰乱了市场这或许是难以招到优秀前端工程师最明显的原因。由于前端工程师的入门门槛非常低，JS、CSS、HTML并不是很难入门掌握的语言，似乎只要花一点时间，无论是谁，都可以通过网上教程或者书本入门。对的，前端工程师市场就是被这些浅尝辄止的家伙搞坏的。 糟糕的前端工程师: JavaScript 类库乱用，对 JavaScript 本身并不了解，什么地方都用 jQuery； 滥用 JavaScript 插件，看都不看看就把别人的代码拿过来用； 不看需求，不做任何的比较和测试，就把CSS 框架加到项目中，但只用了其中 5% 的功能； 认为添加个 CSS Framework，网站就可以变成“响应式的”，或者响应式就像是一些小作料，随便就可以加入到一个网页应用中； 嘴上喊着“响应式的 Web 设计”，但服务端技术一点都不懂； 编写的 CSS 没有任何规范标准，不使用任何预处理器，也没有最佳实践。CSS 代码中充满了过度使用的选择器、ID、神奇的数字以及 !important； 不关心代码的性能和内存泄露（什么是真正的内存泄露也不清楚）,不会对代码进行性能测试； 对产品没有任何的衡量指标，或者把“在我的电脑/浏览器/移动设备上可以工作”为指标； 忽视30年的软件工程实践，毫无章法的开发软件。 要知道，入门容易精通难，计算机和软件的基础对你用 JS 或浏览器编程都非常重要。web 可能是最有影响力的平台和环境之一，在那里执行的程序必须被小心对待。一位优秀的前端工程师不仅要考虑 web 技术和语言，并且还要了解所有不同的组件、系统和概念。 顶级前端工程师需要具备的经验和最佳实践（这才是市场急需的前端）： 了解 DNS 解析，充分利用 CDN，使用多个域名来完成资源的请求以缩短加载时间； 设置 HTTP Headers（Expires, Cache-Control, If-Modified-Since）； 遵循 Steve Souders 给出的全部规则（High Performance Websites）; 知道如何解决 PageSpeed、YSlow、Chrome Dev Tools Audit、Chrome Dev Tools Timeline 显示的所有问题； 知道什么任务该放在服务端，什么任务该放在客户端； 知道使用缓存，DNS 预取和资源预加载技巧； 精通 JavaScript，知道何时自己写何时借组别人的框架或代码，优劣明辨； 熟练使用现代 MVC JavaScript 框架（例如 AngularJS EmberJS React 等），图形库（D3、SnapSVG 等），DOM 操作类库（jQuery、Zepto 等），惰性加载或者模块管理类库（例如 RequireJS、CommonJS 等），任务调用工具（例如 Grunt Gulp 等），包管理工具（Bower Componentjs）以及测试工具（Protractor、Selenium 等）； 掌握图片的格式，每种格式的优点，适用的场景；知道图片优化技巧以及加载策略（雪碧图、懒加载、缓存刷新以及 PNG 交错）； 熟悉 CSS 标准、最新的转换工具积极策略规范（比如 EDM、SMACSS、OOCSS 等）； JavaScript 的计算机科学（内存管理、单进程特性、垃圾回收算法、定时器、作用域、提升以及设计模式）。 换句话说，如果说精通 HTML+CSS+JS，了解后端知识，只是60分的合格前端；那么要想成为受追捧、拿高薪的80分优秀前端，要对业务需求和、架构设计有真正的运用；而100分的顶级前端，则必须要能够兼顾技术和设计，更接近「以前端开发为主的全栈工程师」了。 市场不是缺少前端，而是缺少优秀的前端工程师现在，前端工程师终于在 web 中占有了一席之地。随着多设备、浏览器和Web标准的演变革命，前端正在成为兼顾逻辑、性能、交互、体验的综合性岗位。 虽然现在互联网行业普遍缺少前端工程师，但是我们相信越来越多的人将会加入前端的大军。不仅是因为大多数前端工作提供的优渥薪水和办公环境，也是因为web中的前端编程变得越来越有挑战和意义。 最后，分享一组2015年3~4月跳槽高峰期的100offer拍卖数据，给前端们鼓鼓劲： 前端工程师人均收获 8.2个面试机会，已入职的前端工程师平均 薪资涨幅达39%。其中，前端offer之王共收获47个offer，最高offer薪水38k*16 ，开自某土豪电商。 加油吧，前端！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS3 线性渐变（linear-gradient）]]></title>
      <url>%2F2016%2F12%2F02%2Flinear-gradient%2F</url>
      <content type="text"><![CDATA[CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。而我们今天主要是针对线性渐变来剖析其具体的用法。为了更好的应用 CSS3 Gradient，我们需要先了解一下目前的几种现代浏览器的内核，主要有 Mozilla（Firefox，Flock等）、WebKit（Safari、Chrome等）、Opera（Opera浏览器）、Trident（讨厌的IE浏览器）。 本文忽略IE不管，我们主要看看在 Mozilla、Webkit、Opera 下的应用，当然在 IE 下也可以实现，他需要通过 IE 特有的滤镜来实现，在后面会列出滤镜的使用语法，但不会具体介绍如何实用，感兴趣的可以搜索相关技术文档。 一、线性渐变在 Mozilla 下的应用语法： 1-moz-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* ) 参数：其共有三个参数，第一个参数表示线性渐变的方向，top 是从上到下、left 是从左到右，如果定义成 left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。如图所示： 根据上面的介绍，我们先来看一个简单的例子： HTML： 1&lt;div class=&quot;example example1&quot;&gt;&lt;/div&gt; CSS： 1234.example &#123; width: 150px; height: 80px;&#125; 如无特殊说明，我们后面的示例都是应用这一段 html 和 css 的基本代码。 现在我们给这个div应用一个简单的渐变样式： 123.example1 &#123; background: -moz-linear-gradient( top,#ccc,#000);&#125; 二、线性渐变在 Webkit 下的应用语法： 12-webkit-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* )//最新发布书写语法-webkit-gradient(&lt;type&gt;, &lt;point&gt; [, &lt;radius&gt;]?, &lt;point&gt; [, &lt;radius&gt;]? [, &lt;stop&gt;]*) //老式语法书写规则 参数：-webkit-gradient 是 webkit 引擎对渐变的实现参数，一共有五个。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（径向渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如 left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop 函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。如图所示： 我们先来看一个老式的写法示例： 1background: -webkit-gradient(linear,center top,center bottom,from(#ccc), to(#000)); 接着我们在来看一下新式的写法： 1-webkit-linear-gradient(top,#ccc,#000); 这个效果我就不在贴出来了，大家在浏览器中一看就明白了，他们是否一致的效果。仔细对比，在 Mozilla 和 Webkit 下两者的学法都基本上一致了，只是其前缀的区别，当然哪一天他们能统一成一样，对我们来说当然是更好了，那就不用去处理了。将大大节省我们的开发时间哟。 三、线性渐变在 Opera 下的应用语法： 1-o-linear-gradient([&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]); /* Opera 11.10+ */ 参数：-o-linear-gradient 有三个参数。第一个参数表示线性渐变的方向，top 是从上到下、left 是从左到右，如果定义成 left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。（注：Opera 支持的版本有限，本例测试都是在 Opera11.1 版本下，后面不在提示），如图所示： 示例代码： 1background: -o-linear-gradient(top,#ccc, #000); 四、线性渐变在 Trident (IE) 下的应用语法： 12filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0, startColorstr=#1471da, endColorstr=#1C85FB);/*IE&lt;9&gt;*/-ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient (GradientType=0, startColorstr=#1471da, endColorstr=#1C85FB)&quot;;/*IE8+*/ IE依靠滤镜实现渐变。startColorstr表示起点的颜色，endColorstr 表示终点颜色。GradientType 表示渐变类型，0 为缺省值，表示垂直渐变，1 表示水平渐变。如图所示： 上面我们主要介绍了线性渐变在上述四大核心模块下的实现方法，接着我们主要针对线性渐变在 Mozilla、Webkit、Opera 三大模块下实现各种不同线性渐变实例： 从上面的语法中我们可以很清楚的知道，要创建一个线性渐变，我们需要创建一个起点和一个渐变方向（或角度），定义一个起始色： 123-moz-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* )-webkit-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* )-o-linear-gradient( [&lt;point&gt; || &lt;angle&gt;,]? &lt;stop&gt;, &lt;stop&gt; [, &lt;stop&gt;]* ) 具体应用如下： 1234background:-moz-linear-gradient(left,#ace,#f96);/*Mozilla*/background:-webkit-gradient(linear,0 50%,100% 50%,from(#ace),to(#f96));/*Old gradient for webkit*/background:-webkit-linear-gradient(left,#ace,#f96);/*new gradient for Webkit*/background:-o-linear-gradient(left,#ace,#f96); /*Opera11*/ 效果如下： 起始点（Starting Point）的工作方式类似于 background position。您可以设置水平和垂直位置为百分比，或以像素为单位，或在水平方向上可以使用left/center/right，在垂直方向上可以使用top/center/bottom。位置起始于左上角。如果你不指定水平或垂直位置，它将默认为center。其工作方式主要包含：Top → Bottom、Left → Right、bottom → top、right → left等，接着我们主要一种一种来看其实现的效果： 1、开始于center（水平方向）和top（垂直方向）也就是Top → Bottom：123456789/* Firefox 3.6+ */background: -moz-linear-gradient(top, #ace, #f96);/* Safari 4-5, Chrome 1-9 *//* -webkit-gradient(, [, ]?, [, ]? [, ]*) */background: -webkit-gradient(linear,top,from(#ace),to(#f96));/* Safari 5.1+, Chrome 10+ */background: -webkit-linear-gradient(top, #ace, #f96);/* Opera 11.10+ */background: -o-linear-gradient(top, #ace, #f96); 效果： 2、始于left（水平方向）和center（垂直方向）也是就Left → Right：123456/* Firefox 3.6+ */background: -moz-linear-gradient(left, #ace, #f96);/* Safari 5.1+, Chrome 10+ */background: -webkit-linear-gradient(left, #ace, #f96);/* Opera 11.10+ */background: -o-linear-gradient(left, #ace, #f96); 效果如下： 3、起始于left（水平方向）和top（垂直方向）:123background: -moz-linear-gradient(left top, #ace, #f96);background: -webkit-linear-gradient(left top, #ace, #f96);background: -o-linear-gradient(left top, #ace, #f96); 效果如下： 4、Linear Gradient (with Even Stops):12345678/* Firefox 3.6+ */background: -moz-linear-gradient(left, #ace, #f96, #ace, #f96, #ace);/* Safari 4-5, Chrome 1-9 */background: -webkit-gradient(linear, left top, right top, from(#ace), color-stop(0.25, #f96), color-stop(0.5, #ace), color-stop(0.75, #f96), to(#ace));/* Safari 5.1+, Chrome 10+ */background: -webkit-linear-gradient(left, #ace, #f96, #ace, #f96, #ace);/* Opera 11.10+ */background: -o-linear-gradient(left, #ace, #f96, #ace, #f96, #ace); 效果如下： 5、with Specified Arbitrary Stops：12345678/* Firefox 3.6+ */background: -moz-linear-gradient(left, #ace, #f96 5%, #ace, #f96 95%, #ace);/* Safari 4-5, Chrome 1-9 */background: -webkit-gradient(linear, left top, right top, from(#ace), color-stop(0.05, #f96), color-stop(0.5, #ace), color-stop(0.95, #f96), to(#ace));/* Safari 5.1+, Chrome 10+ */background: -webkit-linear-gradient(left, #ace, #f96 5%, #ace, #f96 95%, #ace);/* Opera 11.10+ */background: -o-linear-gradient(left, #ace, #f96 5%, #ace, #f96 95%, #ace); 效果如下： 6、角度(Angle)：正如上面看到的示例，如果您不指定一个角度，它会根据起始位置自动定义。如果你想更多的控制渐变的方向，您不妨设置角度试试。例如，下面的两个渐变具有相同的起点left center，但是加上一个30度的角度。 没有角度的示例代码： 123background: -moz-linear-gradient(left, #ace, #f96);background: -webkit-linear-gradient(left,#ace,#f96);background: -o-linear-gradient(left, #ace, #f96); 加上30度的角度代码： 123background: -moz-linear-gradient(left 30deg, #ace, #f96);background: -webkit-gradient(linear, 0 0, 100% 100%, from(#ace),to(#f96));background: -o-linear-gradient(30deg, #ace, #f96); 效果图如下： 当指定的角度，请记住，它是一个由水平线与渐变线产生的的角度，逆时针方向。因此，使用0deg将产生一个左到右横向梯度，而90度将创建一个从底部到顶部的垂直渐变。我来看看你核心代码： 1234background: -moz-linear-gradient(&lt;angle&gt;, #ace, #f96);background: -webkit-gradient(&lt;type&gt;,&lt;angle&gt;, from(#ace), to(#f96));background: -webkit-linear-gradient(&lt;angle&gt;, #ace, #f96);background: -o-linear-gradient(&lt;angle&gt;, #ace, #f96); 我们来看看各角度的区别： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.deg0 &#123; background: -moz-linear-gradient(0deg, #ace, #f96); background: -webkit-gradient(linear,0 50%,100% 50%,from(#ace),to(#f96)); background: -webkit-linear-gradient(0deg, #ace, #f96); background: -o-linear-gradient(0deg, #ace, #f96);&#125; .deg45 &#123; background: -moz-linear-gradient(45deg, #ace, #f96); background: -webkit-gradient(linear,0 100%,100% 0%,from(#ace),to(#f96)); background: -webkit-linear-gradient(45deg, #ace, #f96); background: -o-linear-gradient(45deg, #ace, #f96);&#125;.deg90 &#123; background: -moz-linear-gradient(90deg, #ace, #f96); background: -webkit-gradient(linear,50% 100%,50% 0%,from(#ace),to(#f96)); background: -webkit-linear-gradient(90deg, #ace, #f96); background: -o-linear-gradient(90deg, #ace, #f96);&#125;.deg135 &#123; background: -moz-linear-gradient(135deg, #ace, #f96); background: -webkit-gradient(linear,100% 100%,0 0,from(#ace),to(#f96)); background: -webkit-linear-gradient(135deg, #ace, #f96); background: -o-linear-gradient(135deg, #ace, #f96);&#125;.deg180 &#123; background: -moz-linear-gradient(180deg, #ace, #f96); background: -webkit-gradient(linear,100% 50%,0 50%,from(#ace),to(#f96)); background: -webkit-linear-gradient(180deg, #ace, #f96); background: -o-linear-gradient(180deg, #ace, #f96);&#125;.deg225 &#123; background: -moz-linear-gradient(225deg, #ace, #f96); background: -webkit-gradient(linear,100% 0%,0 100%,from(#ace),to(#f96)); background: -webkit-linear-gradient(225deg, #ace, #f96); background: -o-linear-gradient(225deg, #ace, #f96);&#125;.deg270 &#123; background: -moz-linear-gradient(270deg, #ace, #f96); background: -webkit-gradient(linear,50% 0%,50% 100%,from(#ace),to(#f96)); background: -webkit-linear-gradient(270deg, #ace, #f96); background: -o-linear-gradient(270deg, #ace, #f96);&#125;.deg315 &#123; background: -moz-linear-gradient(315deg, #ace, #f96); background: -webkit-gradient(linear,0% 0%,100% 100%,from(#ace),to(#f96)); background: -webkit-linear-gradient(315deg, #ace, #f96); background: -o-linear-gradient(315deg, #ace, #f96);&#125;.deg360 &#123; background: -moz-linear-gradient(360deg, #ace, #f96); background: -webkit-gradient(linear,0 50%,100% 50%,from(#ace),to(#f96)); background: -webkit-linear-gradient(360deg, #ace, #f96); background: -o-linear-gradient(360deg, #ace, #f96);&#125; 效果如下： 除了起始位置和角度，你应该指定起止颜色。起止颜色是沿着渐变线，将会在指定位置（以百分比或长度设定）含有指定颜色的点。色彩的起止数是无限的。如果您使用一个百分比位置，0％代表起点和100％是终点，但区域外的值可以被用来达到预期的效果。 这也是通过CSS3 Gradient制作渐变的一个关键所在，其直接影响了你的设计效果，像我们这里的示例都不是完美的效果，只是为了能给大家展示一个渐变的效果，大家就这样先用着吧。我们接着看一下不同的起址色的示例： 123background: -moz-linear-gradient(top, #ace, #f96 80%, #f96);background: -webkit-linear-gradient(top,#ace,#f96 80%,#f96);background: -o-linear-gradient(top, #ace, #f96 80%, #f96); 效果如下： 如果没有指定位置，颜色会均匀分布。如下面的示例： 123background: -moz-linear-gradient(left, red, #f96, yellow, green, #ace);background: -webkit-linear-gradient(left,red,#f96,yellow,green,#ace);background: -o-linear-gradient(left, red, #f96, yellow, green, #ace); 效果如下： 7、渐变上应用透明度(Transparency)：透明渐变对于制作一些特殊的效果是相当有用的，例如，当堆叠多个背景时。这里是两个背景的结合：一张图片，一个白色到透明的线性渐变。我们来看一个官网的示例吧： 123background: -moz-linear-gradient(right, rgba(255,255,255,0), rgba(255,255,255,1)),url(http://demos.hacks.mozilla.org/openweb/resources/images/patterns/flowers-pattern.jpg);background: -webkit-linear-gradient(right, rgba(255,255,255,0), rgba(255,255,255,1)),url(http://demos.hacks.mozilla.org/openweb/resources/images/patterns/flowers-pattern.jpg);background: -o-linear-gradient(right, rgba(255,255,255,0), rgba(255,255,255,1)),url(http://demos.hacks.mozilla.org/openweb/resources/images/patterns/flowers-pattern.jpg); 接着看看效果吧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript的作用域和块级作用域概念理解]]></title>
      <url>%2F2016%2F11%2F30%2Factive-scope%2F</url>
      <content type="text"><![CDATA[JavaScript的作用域和块级作用域概念理解作用域 作用域永远都是任何一门编程语言中的重中之重，因为它控制着变量与参数的可见性与生命周期。说到这里我们需要理解两个概念：块级作用域与函数作用域。 函数作用域 这个应该好理解，函数作用域就是说定义在函数中的参数和变量在函数外部是不可见的。大多数类C语言都拥有块级作用域，JS却没有。请看下文demo: 12345678910//C语言 #include &lt;stdio.h&gt; void main()&#123; i=2; i--; if(i)&#123; int j=3; &#125; printf(&quot;%d/n&quot;,j); &#125; 运行这段代码，会出现“use an undefined variable:j”的错误。可以看到，C语言拥有块级作用域，因为j是在if的语句块中定义的，因此，它在块外是无法访问的。 块级作用域 任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 正如我们举的C语言的例子，大多数类C语言都是有块级作用域的，那么在JavaScript又有什么不同呢？我们一起看看这个JavaScript的demo: 12345functin test()&#123; for(var i=0;i&lt;3;i++)&#123;&#125; alert(i); &#125; test(); 运行这段代码，弹出”3”，可见，在块外，块中定义的变量i仍然是可以访问的。也就是说，JS并不支持块级作用域，它只支持函数作用域，而且在一个函数中的任何位置定义的变量在该函数中的任何地方都是可见的。 那么我们该如何使JS拥有块级作用域呢？是否还记得，在一个函数中定义的变量，当这个函数调用完后，变量会被销毁，我们是否可以用这个特性来模拟出JS的块级作用域呢？看下面这个demo： 1234567function test()&#123; (function ()&#123; for(var i=0;i&lt;4;i++)&#123;&#125; &#125;)(); alert(i); &#125; test(); 这时候再次运行，会弹出”i”未定义的错误，哈哈，实现了吧~~~这里，我们把for语句块放到了一个闭包之中，然后调用这个函数，当函数调用完毕，变量i自动销毁，因此，我们在块外便无法访问了。 JS的闭包特性is the most important feature((^__^) 大家懂的)。在JS中，为了防止命名冲突，我们应该尽量避免使用全局变量和全局函数。那么，该如何避免呢？不错，正如上文demo所示，我们可以把要定义的所有内容放入到一个之中，这时候，我们是不是相当于给它们的外层添加了一个函数作用域呢？该作用域之外的程序是无法访问它们的。 123(function ()&#123; //内容 &#125;)();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React开发中关于this的那些事儿]]></title>
      <url>%2F2016%2F11%2F29%2FReact-this%2F</url>
      <content type="text"><![CDATA[React开发中关于this的那些事儿在React开发，关于this以及es6中方法的书写及其使用出现一些问题 在es5中, 普通用function声明的函数是定义在window对象上的，显而易见其内部的this肯定是默认指向window对象。而直接用函数名来调用得到的函数内this也是window对象。可以这么理解，那个看不见的调用者就是window 在es6中，为了规范function中this的所属问题，在使用‘use strict’模式下，不显示地用window对象调用函数则其内部的this为undefined，也就是强制你使用window对象严格得去调用。 与this相关的 bind call apply 三兄弟 bind通常用来重新绑定函数体中的this并返回一个具有指定this的函数。 call 和 apply 则表示重新指定this并调用返回结果，区别在于call采用多个实参的方式传参，apply则是使用一个数组。 共同点: 在于第一个参数指定为this(这里用对象描述比较合理些)，作用都是用来重定向this；从第二个参数起都算作是参数传递。 不同点: [1] 是用来返回具有特定this的函数，[2] 是用来调用函数的。而对于函数的获得，则通过其声明宿主(指所在对象，并非es6中的class类。在es6中，class和Java的类似，想要调用需要创建对象) React中的bind准确说，应该是es6中bind的使用，但因为在开发中常用到，就暂且以React开发为背景。因为是返回指定this的函数，因此它的应用场景一定是函数的传递，而非函数的普通调用。在开发中，函数的传递赋值主要有以下几个场景(如有遗漏，欢迎补充)： 组件属性：组件内部函数的回调，通过把一个函数传递给组件的props，本质上和把函数作为实参传递给被调用函数是一致的。(至于是在Jsx中虚拟Dom中传递还是通过createElement、cloneElement等React API就不多说了) 高阶函数：本质上也是一种回调，就是在调用的地方提前写好即将被调用的函数并传进去，这里的‘即将’既可以是同步也可以是异步。 在以上两种情况中，组件的属性对this的依赖还是比较大的 当我们给组件属性所传递的函数中，需要使用到当前类中非静态函数或字段(这两种成员都归属于this)时就不得不使用this来调用。 使用场景一12345678910class Foo extends Component&#123; render () &#123; return &lt;CustomView onPress=&#123;this.readBook&#125; /&gt; &#125; readBook () &#123; let bookName = this.getBookName() this.props.ooxx this.state.ooxx &#125;&#125; 以上代码在运行时，由于this.readBook传递了一个纯函数，而该函数在CustomView类中执行时，this会被指向当前类CustomView的实例this,显而易见此时的foo、props、ooxx显然在另外一个类中是找不到的，undefined这个老朋友的如约而至也成为必然。 此时我们只需要改写传入方式为this.readBook.bind(this)即可将当前this绑定到readBook中，当然也可以绑定其他你所想要的，只要符合你的需求。 使用场景二由于让函数调用bind会返回一个全新的函数，因此在高阶函数的某些场景下就会因为不是同一个函数(准确说是引用) 而导致出错，如监听器的注册与注销: 12345678910111213141516class PauseMenu extends Component &#123; constructor (props) &#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount () &#123; AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused); &#125; componentDidUnmount () &#123; AppStateIOS.removeEventListener( &apos;change&apos;, this._onAppPaused ) &#125; onAppPaused(event)&#123; &#125;&#125; 可以看到我们在构造函数里为onAppPaused函数单独绑定了this并存到当前this当中，这样在注册和注销的时候都可以保证拿到的是同一个函数对象。(这里需要注意，_onAppPaused是直接定义在this上的，因此在针对一个class new出实例后，_onAppPaused是属于实例的，而onAppPaused是定义在类里的非静态函数，在类的prototype上，实例的proto原型上的。) 在bind时传参数这个需求，就我个人来讲是一个非常不合理的需求。高阶函数本来就是传入一个方法签名，而你非要利用bind的附加参数功能有点‘乱来’的意思了。不过也不是不可以，只需要注意此时如果在高阶函数内(或组件内) 的方法回调中本身带有参数，则在bind时禁止附加参数，否则会覆盖原有的回调参数。 Lambda表达式与匿名函数Lambda表达式是es6中函数的一种新的声明方式，如下： 123() =&gt; &#123; console.log(...)&#125; 以上是一个简单的Lambda表达式，在多数的Js教程中都被称作”箭头函数”，它的书面写法上等价于匿名函数，如下: 123function () &#123; console.log(...)&#125; 他们都可以被用来在高阶函数以及组件属性上以及普通方法的定义，然而又有一些差异: Lambda表达式中的this指向当前作用域的this，因此这种情况下就没有bind的事情了，因为Lambda已经有自己的this了。同bind一样，Lambda同样会返回一个全新的函数。 1&lt;CustomView onPress=&#123;() =&gt; this.props...&#125; /&gt; 此时呢，Lambda表达式是直接作为回调被赋值了。因此所有的回调参数都可以在此获取到，后续与this相关的逻辑代码都可以在Lambda表达式中书写。 匿名函数会因为es5、6的情况而指向window或者undefined，此时如果方法体内需要用到当前的组件的this，则可以通过bind来完成，如： 123&lt;CustomView onPress=&#123;function()&#123; this.props...&#125;.bind(this)&#125; /&gt; 这样的代码等价于使用函数名bind this一样，如： 12345&lt;CustomView onPress=&#123;this.readProps.bind(this)&#125; /&gt;...readProps () &#123; this.props...&#125; 如果上边的readProps的回调没有传出一些特别的参数，也可以用Lambda表达式改为: 1&lt;CustomView onPress=&#123;() =&gt; this.readProps()&#125; /&gt; 当然，这只是用箭头函数包裹了一下，我们仍然可以通过在箭头函数的参数列表中声明参数的方式来达到相同的目的。 使用Lambda表达式优化之前提到了用bind在this中存留一份，可以在构造函数里用对象的属性来存储唯一的函数。 12345678910class PauseMenu extends Component &#123; componentWillMount () &#123; AppStateIOS.addEventListener(&apos;change&apos;, this._onAppPaused); &#125; componentDidUnmount () &#123; AppStateIOS.removeEventListener(&apos;change&apos;, this._onAppPaused) &#125; _onAppPaused ＝ (event) =&gt; &#123; &#125;;&#125; 这样做可以将_onAppPaused 作为类属性的一部分，就不用担心拿不到方法的唯一引用啦 Lambda表达式补充： 箭头后的部分即为表达式的返回值 如果出现多条语句操作运算的，需要使用{…} 以函数体的形式书写并以显示的方式return返回值 如果需要直接返回一个Object的话，语法上会和函数体冲突，此时就必须使用()保护一下，声明此处是一个对象而非函数体 参数方面，单参数可以不加()括弧, 但是一个以上就必须要加了。同时没有参数时需要使用()来完成语法上的补位 结语在日常开发中，this还是一个让人比较头疼的东西。方法(对象中的函数) 内函数会导致this的重定向，其他的一些对象嵌套也会导致重定向问题，因此大家不要慌，不妨尝试手动获取一下外部this。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于图片的懒加载]]></title>
      <url>%2F2016%2F11%2F28%2Flazyload%2F</url>
      <content type="text"><![CDATA[目前，一些图片类型的网站上，在图片加载时均采用了一种名为懒加载的方式，具体表现为，当页面被请求时，只加载可视区域的图片，其它部分的图片则不加载，只有这些图片出现在可视区域时才会动态加载这些图片，从而节约了网络带宽和提高了初次加载的速度，具体实现的技术并不复杂，下面分别对其说明。首先，在页面中准备一个id为div1的div,在这个div中放一个ul,ul中准备了一些li,然而这些li都有一个data-src的属性，准备着图片的地址，具体结构如下： 123456789101112131415161718192021222324252627&lt;div id=&quot;div1&quot;&gt; &lt;ul&gt; &lt;li data-src=&quot;http://4493bz.1985t.com/uploads/allimg/140710/1-140G0161612.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://4493bz.1985t.com/uploads/allimg/140628/1-14062Q33R6.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://4493bz.1985t.com/uploads/allimg/140628/1-14062Q33242.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://img.bizhi.sogou.com/images/2014/12/10/997251.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://dl.bizhi.sogou.com/images/2014/12/02/986640.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170473_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170475_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170477_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;http://imgstore.cdn.sogou.com/app/a/100540002/1170479_s_90_2_219x160.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 图片的动态加载就是通过读取li元素，然后获得li元素的data-src属性的值赋予动态创建的图片的src，从而实现了图片的创建。 123456789101112131415function setImg(index)&#123; var oDiv=document.getElementById(&quot;div1&quot;) var oUl=oDiv.children[0]; var aLi=oUl.children; if (aLi[index].dataset) &#123; var src=aLi[index].dataset.src; &#125; else&#123; var src=aLi[index].getAttribute(&apos;data-src&apos;); &#125; var oImg=document.createElement(&apos;img&apos;); oImg.src=src; if (aLi[index].children.length==0) &#123; aLi[index].appendChild(oImg); &#125;&#125; 那么怎么识别是否在可视区域呢？这里需要一个函数，能够实现获得当前元素距离网页顶部的距离！ 123456789//获得对象距离页面顶端的距离 function getH(obj) &#123; var h = 0; while (obj) &#123; h += obj.offsetTop; obj = obj.offsetParent; &#125; return h; &#125; 当网页的滚动条滚动时要时时判断当前li的位置！ 1234567891011121314 window.onscroll = function () &#123; var oDiv = document.getElementById(&apos;div1&apos;); var oUl = oDiv.children[0]; var aLi = oUl.children; for (var i = 0, l = aLi.length; i &lt; l; i++) &#123; var oLi = aLi[i]; //检查oLi是否在可视区域 var t = document.documentElement.clientHeight + (document.documentElement.scrollTop || document.body.scrollTop); var h = getH(oLi); if (h &lt; t) &#123; setTimeout(&quot;setImg(&quot; + i + &quot;)&quot;, 500); &#125; &#125;&#125;; 当页面加载完成以后要主动运行一下window.onscroll，从而获得当前可视范围内的图片 123window.onload = function () &#123; window.onscroll();&#125;; 另外，像这样的页面，障眼法和美化都是必须的，比如给每个li一个loading的图片作为背景，从而实现了当前图片正在加载的效果，美化工作就是做好合理的布局。 12345678910111213141516171819202122* &#123; margin: 0; padding: 0;&#125;#div1 &#123; width: 520px; margin: 30px auto; border: 1px solid red; overflow: hidden;&#125;li &#123; width: 160px; height: 160px; float: left; list-style: none; margin: 5px; background: url(loading.gif) center center no-repeat; border: 1px dashed green;&#125;img&#123; width:100%&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS Float 以及相关布局模式]]></title>
      <url>%2F2016%2F11%2F26%2Ffloat%2F</url>
      <content type="text"><![CDATA[CSS Float 以及相关布局模式float 取值 属性 值 描述 left 向左浮动 right 向右浮动 none 默认值 inherit 继承 举个例子红色线框代表父元素 脱离文档流，其实也没有完全脱离，会被父元素的边界挡住。 float的元素在同一文档流看个例子：红线框代表父元素 三个子元素『向左浮动』之后， 父元素就没有内容了，所以父元素没有高度了。 float元素半脱离文档流对元素，脱离文档流；对内容，在文档流。元素时会重叠，但是内容不会重叠。 举个例子： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;float元素半脱离文档流&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width: 300px;padding: 5px;line-height: 1.6; border: 1px dashed blue; &#125; .sample&#123; height: 100px;margin-right: 5px; padding: 0 5px; line-height: 100px;background-color: pink; &#125; .sb&#123; outline: 1px dashed red; &#125; .sample&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;sample&quot;&gt;float : left &lt;/div&gt; &lt;div class=&quot;sb&quot;&gt;A float is a box that is shifted to the left or right on the current line .the most interesting characteristic of a float (o &quot;floated&quot; o &quot;floating&quot; box)is that content may flow along its side (or be prohibited from doing so by the &apos;clear&apos;property).&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再举个例子： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;float abscure&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width: 400px;line-height: 1.6; &#125; .sample&#123; width: 100px;line-height: 100px; margin: 3px;text-align: center; background-color: pink; &#125; .sb&#123; margin: 10px auto; padding: 5px; border: 1px dashed #0f00fa; &#125; .sample&#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;sb&quot;&gt; &lt;div class=&quot;sample&quot;&gt;float: left;&lt;/div&gt; 第十二届ChinaJoy 动漫游戏展7月31号在上海新国际博览中心开幕，导出是站台表演的帅哥美女。 &lt;/div&gt; &lt;div class=&quot;sb&quot;&gt; 有些游戏商为了吸引人气，还请来了著名的演员、模特前来助阵。以下是一批漂亮的Show Girl现场照片。 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通常我们并不想要这个结果，而是粉色div 只被第一个文字块环绕。 需要使用clear属性 clear要理解clear，首先要知道 div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的流 属性名 值 描述 clear both 包含left 和 right left 左侧不允许其他浮动元素 right 右侧不允许其他浮动元素 none 默认值 inherit ①应用于后续元素, 来清除浮动对后续的影响。 ②应用于块级元素 使用方式：增加一个空白元素(用得较少) clearfix，这是一般通用方案。实际上是用一个不可用的点号，来清除浮动。 举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;float abscure&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; width: 400px;line-height: 1.6; &#125; .sample&#123; width: 100px;line-height: 100px; margin: 3px;text-align: center; background-color: pink; &#125; .sb&#123; margin: 10px auto; padding: 5px; border: 1px dashed #0f00fa; &#125; .sample&#123; float: left; &#125; .clearfix:after&#123; content: &apos;.&apos;; // 在clearfix后面加入一个 display: block; // 设置 . 块级元素 clear: both; //清除浮动效果 // 隐藏那个 height: 0; overflow: hidden; visibility: hidden; &#125; //.clearfix&#123; zoom: 1; 由于在IE 低版本中，不支持after属性，所以需要增加zoom属性 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;sb clearfix&quot;&gt; &lt;div class=&quot;sample&quot;&gt;float: left;&lt;/div&gt; 第十二届ChinaJoy 动漫游戏展7月31号在上海新国际博览中心开幕，导出是站台表演的帅哥美女。 &lt;/div&gt; &lt;div class=&quot;sb&quot;&gt; 有些游戏商为了吸引人气，还请来了著名的演员、模特前来助阵。以下是一批漂亮的Show Girl现场照片。 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop之间的区分]]></title>
      <url>%2F2016%2F11%2F26%2FHeight-Top%2F</url>
      <content type="text"><![CDATA[搞清 clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop每个HTML元素都具有clientHeight offsetHeight scrollHeight offsetTop scrollTop 这5个和元素高度、滚动、位置相关的属性，单凭单词很难搞清楚分别代表什么意思之间有什么区别。通过阅读它们的文档总结出规律如下： clientHeight和offsetHeight属性和元素的滚动、位置没有关系它代表元素的高度，其中： clientHeight：包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素 offsetHeight：包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。 接下来讨论出现有滚动条时的情况：当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时: scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight&gt;=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。 scrollTop: 代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立。单位px，可读可设置。 offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FlexBox标准及兼容写法速查表]]></title>
      <url>%2F2016%2F11%2F25%2Fflexbox%2F</url>
      <content type="text"><![CDATA[flexbox标准及兼容写法速查表flexbox标准写法:支持浏览器: IE11, Chrome29+, FireFox 20+, Safari加前缀 -webkit-概述: 总的来说就是12个属性; 关于容器的6个,5个单一属性,分别定义了元素排列的方向, 行, 水平排列, 垂直排列, 空白分布, 和一个简写属性, 方向,行关于容器内元素的6个, 5个单一属性, 分别定义元素的顺序, 伸展, 收缩, 初始尺寸, 对齐, 和一个简写属性 描述元素尺寸 container : display: flex / inline-flex; 说明 flex-direction: row / column / row-reverse / column-reverse 元素在容器内的排列方向 flex-wrap: nowrap / wrap / wrap-reverse 元素一行或多行显示 flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt; default: &lt;row nowrap&gt; / column-reverse 上面两个属性的简写 justify-content: flex-start / flex-end / center / space-between / space-around 水平方向上, 元素在容器内的分布 align-items: stretch / flex-start / flex-end / center / baseline 垂直方向上,元素在容器内的分布 align-content: stretch / flex-start / flex-end / center / space-between / space-around 在容器内, 额外的空白部分的分布 Container items : 说明 order: &lt;number&gt; 0 元素在容器内的排列顺序 align-self: auto / flex-start / flex-end / center / baseline / stretch 覆盖align-items的值, 定义自身在垂直方向上的分布 flex-grow: &lt;number&gt; 0 元素在容器内所占空间的伸展 flex-shrink: &lt;number&gt; 1 元素在容器内所占空间的收缩 flex-basis: &lt;width&gt; auto 初始化时, 元素在容器内的尺寸 flex: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; &lt;0 1 auto&gt; 上面三个属性的简写 *以上&lt;number&gt;不支持负值; *每个属性的第一个取值为默认值; *蓝色为多个属性简写模式; 兼容IE10:加前缀 -ms- display:-ms-flexbox / -ms-inline-flexbox; standard -ms-flex-direction : row / column / row-reverse / column-reverse flex-direction -ms-flex-wrap : none / wrap / wrap-reverse flex-wrap 不支持 flex-flow -ms-flex-pack : start / end /center / justify justify-content -ms-flex-align : stretch / start / end /center / baseline align-items -ms-flex-line-pack : start / end /center / baseline align-content -ms-flex-order : &lt;number&gt; order -ms-flex-item-align : stretch / start / end /center / baseline align-self -ms-flex : &lt;positive-flex&gt; &lt;negative-flex&gt; &lt;preferred-size&gt; none flex : 0 0 auto *IE10之前不建议使用,可以尝试用display:table; 关于Chrome,FireFox旧版本支持:FireFox:把 -webkit- 换成 -moz- 即可 container : display: -webkit-flexbox / -webkit-inline-flexbox; standard -webkit-box-direction: normal / reverse flex-direction -webkit-box-orient: horizontal / vertical flex-direction 不支持 flex-wrap 不支持 flex-flow -webkit-box-pack: flex-start / flex-end / center / space-between / space-around justify-content -webkit-box-align: stretch / flex-start / flex-end / center / baseline align-items 不支持 align-content -webkit-box-ordinal-group: &lt;number&gt; order -webkit-box-flex: &lt;number&gt; 1 flex-grow -webkit-flex-shrink: &lt;number&gt; 0 flex-shrink -webkit-flex-basis: &lt;width&gt; auto (无-moz-) flex-basis -webkit-box: &lt;flex-grow&gt; &lt;flex-shrink&gt; &lt;flex-basis&gt; &lt;1 0 auto&gt; flex 不支持 align-self 兼容多浏览器的预定义写法: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Advanced_layouts_with_flexbox]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iframe关于滚动条的去除和保留]]></title>
      <url>%2F2016%2F11%2F25%2Fiframe%2F</url>
      <content type="text"><![CDATA[iframe关于滚动条的去除和保留iframe嵌入页面后，我们有时需要调整滚动条，例如，去掉全部的滚动条，去掉右边的滚动条且保留底下的滚动条，去掉底下的滚动条且保留右边的滚动条。那么我们应该怎么做呢？ 一：去掉全部的滚动条 第一个方法： iframe 有一个scrolling属性，它有 auto , yes , no 这三个值。 scrolling : auto —–在需要的时候滚动条出现 scrolling : yes ——始终显示滚动条 scrolling : no ——-始终隐藏滚动条当设置 scrolling : no 时，全部的滚动条就没有了。 第二个方法：我发现除了 scrolling 可以去掉全部的滚动条外，还有另一个方法，在嵌入的页面里设置 body{overflow：hidden}，这样也可以将滚动条去掉，而且这也是当我们只想去掉某一个滚动条所使用的属性。 二：去掉右边的滚动条且保留底下的滚动条如果只想保留底下的滚动条，那么可以在嵌入的页面里设置 1body&#123;overflow-x：auto ; overflow-y：hidden；&#125; 三：去掉底下的滚动条且保留右边的滚动条在嵌入的页面里设置 1body&#123;overflow-x：hidden；overflow-y：auto；&#125; 我们已经知道了这两个属性都可以设置滚动条的显示和隐藏，那么当两个同时设置时，会出现哪个效果呢？ 通过检测，我发现当scrolling = &quot; auto &quot;或者&quot; yes &quot;时，如果设置了 body，那么就会使用body里的设置；当scrolling = &quot; no &quot;时，不管body设置了什么，都会使用scrolling的设置，即全部的滚动条都被去掉了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM的概念及子节点类型]]></title>
      <url>%2F2016%2F11%2F25%2FDOM%2F</url>
      <content type="text"><![CDATA[##DOM的概念及子节点类型 前言DOM的作用是将网页转为一个javascript对象，从而可以使用javascript对网页进行各种操作(比如增删内容)。浏览器会根据DOM模型，将HTML文档解析成一系列的节点，再由这些节点组成一个树状结构。DOM的最小组成单位叫做节点(node)，文档的树形结构(DOM树)由12种类型的节点组成。 一、DOMDOM ==&gt; 全称： document Object Mode 文档对象模型 文档： html页面 文档对象：页面元素（节点） 文档对象模型： W3C标准定义：为了能够使用javascript去操作页面中的元素定义出来的标准 二、DOM会把文档当成一节点树，文档里面的每一个元素都是一个节点。同时定义了很多方法来操作这些节点（元素）三、属性什么是属性：1.使用的时候不用再前面加括号 2.一个属性肯定是某个对象下面的，所以在使用的时候肯定是调用某个对象（元素）下面的属性 元素.childNodes（存在兼容性，不推荐使用，推荐使用另一个 children） 元素.children （不管在标准还是非标准下，只包含元素类型的节点。推荐使用 特点：只读属性。 代表：子节点列表集合,试剂盒就有长度，可使用数组形式获取(只包含儿子子节点，不包含孙子子节点) 获取：实行 [] 下表获取 标准模式下（非IE）：childNodes 包含了文本和元素类型节点，也会包含非法嵌套的子节点（注意：不是孙子节点） 非标准：childNodes只包含元素类型的节点。ie7以不会包含非法嵌套子节点 ul元素下面的所有子元素都包括在这个childNodes属性里面 访问ul里面的所有 li 子元素形式： var oul = document.getElementById(&apos;ul&apos;); oul.childNodes.length// 9 标准模式下 123456&lt;ul id=&apos;ul&apos;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 为什么是9呢？ DOM里面定义了12种节点： 一般地，节点至少拥有nodeType、nodeName和nodeValue这三个基本属性。 元素.nodeType 只读属性，代表当前元素的类型 nodeType属性返回节点类型的常数值。不同的类型对应不同的常数值，12种类型分别对应1到12的常数值 元素.attributes 只读属性，代表当前元素的属性是什么（如：id，border，，，等属性） 属性列表集合 属性的名称：元素.attributes[0].name 属性的值：元素.attributes[0].value 12345678910&lt;ul id=&apos;ul&apos; style= &apos;color&apos;,&apos;red&apos;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;var oul = document.getElementById(&apos;ul&apos;);oul.attributes.length //2oul.attributes[0].name //id元素.attributes[1].value //red 元素节点 Node.ELEMENT_NODE(1) nodeType值： 1 属性节点 Node.ATTRIBUTE_NODE(2) nodeType值： 2 文本节点 Node.TEXT_NODE(3) nodeType值： 3 CDATA节点 Node.CDATA_SECTION_NODE(4) nodeType值： 4 实体引用名称节点 Node.ENTRY_REFERENCE_NODE(5) nodeType值： 5 实体名称节点 Node.ENTITY_NODE(6) nodeType值： 6 处理指令节点 Node.PROCESSING_INSTRUCTION_NODE(7) nodeType值： 7 注释节点 Node.COMMENT_NODE(8) nodeType值： 8 文档节点 Node.DOCUMENT_NODE(9) nodeType值： 9 文档类型节点 Node.DOCUMENT_TYPE_NODE(10) nodeType值： 10 文档片段节点 Node.DOCUMENT_FRAGMENT_NODE(11) nodeType值： 11 DTD声明节点 Node.NOTATION_NODE(12) nodeType值： 12 DOM定义了一个Node接口，这个接口在javascript中是作为Node类型实现的，而在IE8-浏览器中的所有DOM对象都是以COM对象的形式实现的。所以，IE8-浏览器并不支持Node对象的写法 11 //在标准浏览器下返回1，而在IE8-浏览器中报错，提示Node未定义 2 console.log(Node.ELEMENT_NODE);//1 nodeName nodeName属性返回节点的名称 nodeValue nodeValue属性返回或设置当前节点的值，格式为字符串 接下来，将按照节点类型的常数值对应顺序，从1到12进行详细说明 【1】元素节点元素节点element对应网页的HTML标签元素。元素节点的节点类型nodeType值是1，节点名称nodeName值是大写的标签名，nodeValue值是null 以body元素为例 12345// 1 &apos;BODY&apos; nullconsole.log(document.body.nodeType,document.body.nodeName,document.body.nodeValue)console.log(Node.ELEMENT_NODE === 1);//true 【2】特性节点元素特性节点attribute对应网页中HTML标签的属性，它只存在于元素的attributes属性中，并不是DOM文档树的一部分。特性节点的节点类型nodeType值是2，节点名称nodeName值是属性名，nodeValue值是属性值 现在，div元素有id=”test”的属性 1234567&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script&gt; var attr = test.attributes.id; //2 &apos;id&apos; &apos;test&apos; console.log(attr.nodeType,attr.nodeName,attr.nodeValue) console.log(Node.ATTRIBUTE_NODE === 2);//true &lt;/script&gt; 【3】文本节点文本节点text代表网页中的HTML标签内容。文本节点的节点类型nodeType值是3，节点名称nodeName值是’#text’，nodeValue值是标签内容值 现在，div元素内容为’测试’ 1234567&lt;div id=&quot;test&quot;&gt;测试&lt;/div&gt;&lt;script&gt; var txt = test.firstChild; //3 &apos;#text&apos; &apos;测试&apos; console.log(txt.nodeType,txt.nodeName,txt.nodeValue) console.log(Node.TEXT_NODE === 3);//true &lt;/script&gt; 【4】CDATA节点CDATASection类型只针对基于XML的文档，只出现在XML文档中，表示的是CDATA区域，格式一般为 12&lt;![CDATA[]]&gt; 该类型节点的节点类型nodeType的值为4，节点名称nodeName的值为’#cdata-section’，nodevalue的值是CDATA区域中的内容 【5】实体引用名称节点实体是一个声明，指定了在XML中取代内容或标记而使用的名称。 实体包含两个部分， 首先，必须使用实体声明将名称绑定到替换内容。 实体声明是使用 &lt;!ENTITY name “value”&gt; 语法在文档类型定义(DTD)或XML架构中创建的。其次，在实体声明中定义的名称随后将在 XML 中使用。 在XML中使用时，该名称称为实体引用。 实体引用名称节点entry_reference的节点类型nodeType的值为5，节点名称nodeName的值为实体引用的名称，nodeValue的值为null 1234//实体名称&lt;!ENTITY publisher &quot;Microsoft Press&quot;&gt;//实体名称引用&lt;pubinfo&gt;Published by &amp;publisher;&lt;/pubinfo&gt; 【6】实体名称节点上面已经详细解释过，就不再赘述 该节点的节点类型nodeType的值为6，节点名称nodeName的值为实体名称，nodeValue的值为null 【7】处理指令节点处理指令节点ProcessingInstruction的节点类型nodeType的值为7，节点名称nodeName的值为target，nodeValue的值为entire content excluding the target 【8】注释节点注释节点comment表示网页中的HTML注释。注释节点的节点类型nodeType的值为8，节点名称nodeName的值为’#comment’，nodeValue的值为注释的内容现在，在id为myDiv的div元素中存在一个我是注释内容 1234567&lt;div id=&quot;myDiv&quot;&gt;&lt;!-- 我是注释内容 --&gt;&lt;/div&gt;&lt;script&gt; var com = myDiv.firstChild; //8 &apos;#comment&apos; &apos;我是注释内容&apos; console.log(com.nodeType,com.nodeName,com.nodeValue) console.log(Node.COMMENT_NODE === 8);//true &lt;/script&gt; 【9】文档节点 文档节点document表示HTML文档，也称为根节点，指向document对象。文档节点的节点类型nodeType的值为9，节点名称nodeName的值为’#document’，nodeValue的值为null 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var nodeDocumentType = document.firstChild; //10 &quot;html&quot; null console.log(nodeDocumentType.nodeType,nodeDocumentType.nodeName,nodeDocumentType.nodeValue); console.log(Node.DOCUMENT_TYPE_NODE === 10);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 【11】文档片段节点 文档片段节点DocumentFragment在文档中没有对应的标记，是一种轻量级的文档，可以包含和控制节点，但不会像完整的文档寻亲战胜额外的资源。该节点的节点类型nodeType的值为11，节点名称nodeName的值为’#document-fragment’，nodeValue的值为null 123456&lt;script&gt; var nodeDocumentFragment = document.createDocumentFragment(); //11 &quot;#document-fragment&quot; null console.log(nodeDocumentFragment.nodeType,nodeDocumentFragment.nodeName,nodeDocumentFragment.nodeValue); console.log(Node.DOCUMENT_FRAGMENT_NODE === 11);//true&lt;/script&gt; 【12】DTD声明节点 DTD声明节点notation代表DTD中声明的符号。该节点的节点类型nodeType的值为12，节点名称nodeName的值为符号名称，nodeValue的值为null 总结在这12种DOM节点类型中，有一些适用于XML文档，有一些是不常用的类型。而对于常用类型，后面会陆续进行详细介绍，本文对这12种节点类型只做概述，希望本文对大家能有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex-box弹性盒子布局]]></title>
      <url>%2F2016%2F11%2F25%2Fflex%2F</url>
      <content type="text"><![CDATA[flex-box弹性盒子布局flex布局图 伸缩容器和伸缩项目伸缩容器属性 display flex-direction 定义主轴的方向 flex-wrap 定义主轴方向空间不足，是否换行以及换行方式。 flex-flow 该属性是direction wrap两个属性的缩写。 justify-content 定义伸缩项目沿主轴的对齐方式 align-items 定义伸缩项目在伸缩容器交叉轴的对齐方式 align-content 主要用来调整伸缩项目出现换行后在交叉轴上的对齐方式。 伸缩项目的属性 order 定义项目的排列顺序 数值越小越靠前 flex-grow 定义分配给伸缩项目的剩余空间 flex-shrink 定义伸缩项目的收缩能力 flex-basis 定义伸缩项目的基准值，空余空间按比率伸缩 flex： grow shrink basis 属性的缩写 align-self 设置单独的伸缩项目在交叉轴上的对齐方式 display flex 定义块级伸缩容器 inline-flex 定义行级伸缩容器 flex-direction row 默认值 主轴若为水平方向，则项目从左到右 row-reverse 主轴若为水平方向，则项目从右到左 column 主轴若为垂直方向，则项目从上到下 column-reverse 主轴若为垂直方向，则项目从下到上 flex-wrap no-wrap 默认值 空间不足 也不换行 wrap 空间不足，允许换行，主轴为水平轴，换行方向从上到下 wrap-reverse 允许换行，主轴为水平轴，换行方向从下到上 flex-flow flex-flow:flex-diretion flex-wrap justify-content flex-star 默认值 伸缩项目向主轴线的起始位置靠齐 flex-end 伸缩项目向主轴线的终点位置靠齐 center 伸缩项目向主轴线的起始位置靠齐 space-between 伸缩项目平均分布在主轴线里，第一个在起始位置，最后一个在终点位置 space-around 伸缩项目平均分布在主轴线里，两端保留一半空间 align-items stretch 默认值 伸缩项目在交叉轴方向拉伸填充整个容器 flex-star 伸缩项目向交叉轴的起始位置靠齐 flex-end 伸缩项目向交叉轴的终点位置靠齐 center 伸缩项目向交叉轴的中间位置靠齐 baseline 伸缩项目根据他们的基线靠齐（结合padding了解基线） align-content flex-start 默认值 伸缩项目向交叉轴的起始位置靠齐 flex-end 伸缩项目向交叉轴的结束位置靠齐 center 伸缩项目向交叉轴的中间位置靠齐 space-between 伸缩项目向交叉轴中平均分布，第一排靠起始位置，最后一排靠结束位置 space-around 伸缩项目向交叉轴中平均分布，两边各有一半的空间 stretch 默认值 伸缩项目会在交叉轴上伸展占用余剩的空间 （no-height） order order:integer 默认值为0(试试负数) flex-grow 该属性定义伸缩项目的放大比例：默认值为 0，即有剩余空间也不放大。 需要所有项目都定义成grow,不然没有效果 设置为3，伸缩空间是其他伸缩项目的3倍， flex-shrink flex-shrink:number 默认值为1 空间不足的时候，这个元素可以缩小到设的值 ex:flex-shrink:3 可以缩小到1/3 flex-basis flex-basis:length | auto flex flex-grow flex-shrink flex-basis三个属性的缩写 flex:none | flex-grow flex-shrink flex-basis | auto flex:none (0 0 auto) flex:auto(11 auto) align-self auto flex-start flex-end center baseline stretch]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[line-height，vertical-align及图片居中对齐]]></title>
      <url>%2F2016%2F11%2F23%2Fimage-center%2F</url>
      <content type="text"><![CDATA[line-height，vertical-align及图片居中对齐问题根源解析主要的问题如下： 1.line-height是个什么东西，范围在哪里，具体应用于什么元素？ 2.vertiacal-align和line-height有什么关系，元素对齐到底是一个什么样的过程。 3.图片对齐和文本对齐有什么区别？ 4.浮动元素为什么对齐会出现问题？ 解答这些问题，牵涉的碎片化知识： 基线，底端，行内框，行框，行间距，替换元素及非替换元素，对齐 下面围绕着上面的几个问题，以及相应的碎片化知识点来进行解析问题。一般来说，之所以不了解vertical-align，是因为不清楚对齐后面的这些碎片化知识，而这些也是很多博客在解析的时候常常忽略的地方。 先说结论：1.line-height是行高，主要作用是在文本上下行间距，基于文本产生影响文本元素位置的作用，对于行内元素的位置影响显著，但是对于块元素的影响甚微。 2.vertical-align和line-height的关系是：line-height是vertical-align的对齐依据。vertical-align主要是影响行内元素的对齐，不影响块元素布局。 而决定行内元素对齐的有两个因素: 1.元素本身的height（类似于图片和按钮等替换元素） 2.还有其他span、em非替换元素的line-height。行框通过计算height，line-height，来将各个行内元素与行内的基线进行对齐。 但是当产生浮动的时候，浮动会对行内元素的布局产生特殊影响，因此不会按照原先的方式来进行对齐，此时设置了vertical-align往往没有效果。 3.图片的对齐是将自己的底端，也就是图片的最下端与行框的默认基线进行对齐，对齐依据是底端。影响图片对齐的依据是图片的height、padding、border大小。 而文本元素，例如 &lt;span&gt;文本内容&lt;/span&gt; ，则是将自身的行内框基线与行框基线进行对齐，对齐依据是基线。影响行内文本元素的依据是line-height，以及元素自身的font属性。 4.元素浮动之后实际上是从正常的文档流中除去了（因此会出现高度塌陷，父容器收缩的问题），但是同时又对文档产生着影响（最经典的就是环绕效果）。元素浮动类似于一个被除名的黑户，虽然不在土地登记簿上，但是的的确确占用一块地方，因此别的元素也不能因此占据浮动元素的空间，但是因为是黑户，所以别的元素会环绕它，好像它不存在一样。 因此此时行内元素浮动之后，浮动的规则会覆盖vertical-align的规则，这个时候设置vertical-align往往会出现问题，最典型的就是对一个段落中的图片进行浮动，然后设置vertical-align，但是发现往往不起作用。 但是文本元素浮动之后往往不会受到影响，因为line-height实际上还是作用于文本元素的，虽然文本元素的容器位置“漂”到其他位置，但是里面的文本因为line-height，仍然有行高，可以影响到行内元素的布局。 结论如何推导出来看完这些结论，想必很多人也是一时之间有些不明白所以然，因为不同的人掌握的背景知识是不同的，而这些结论的关键恰恰是这些关键性的碎片化知识，它们起到了穿针引线的作用。下面来梳理一下，到底是怎么得出结论的。 1.核心问题：关于对齐对齐涉及到两个对象，要对齐元素及对齐对象，一个对象是不可能对齐。比如平常在战队，从高往低对齐，每个人都要有一个参考系，对着参考系进行对齐。 而行内元素的对齐，除了行内元素本身，还有一个参考系，这个参考系就是行框的基线，而行框的基线依据于行内框元素的基线位置。 1.1对齐延伸问题：什么是基线？每一个文本元素自身都会有四条线，顶线，中线，基线，底线。而基线一般是指文本元素中以x字母为准，x字母的下边缘为该文本元素的基线。 而行高则是两个文本行基线之间的距离，往往使段落产生间距。 但是也可以这样理解，行高 = 字体大小 + 上半行距 + 下半行距（其中上下半行距相等，这个等式可以从图中推导出来） 每一个文本元素和文本行元素，都会有一条基线，基线的位置受到文本的字体格式以及line-height的影响。 1.2对齐延伸问题：什么是行框和行内框？ 在每一个段落行内，不同的行内元素除了包裹自身内容的内容框之外，还会自动生成一个行内框，其中没有标签包裹的文本会生成匿名行内框，不同的行内框会根据各自不同的line-height产生行间距，而行框则会刚好包括最高的顶端和最低的底端，从而来生成行框。 行内框的基线很好计算，但是行框的基线如何计算呢？行框的基线是立足于行内框中基线最低的元素，也就是line-height最大的文本元素。 下面的例子，可以测试出来，当设置其中一个行内文本元素的line-height超过其他行内元素的line-height的时候，整个容器会自动扩展，位置也会往下移动。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;title&gt;测试行框基线&lt;/title&gt;&lt;style&gt; p&#123; border:1px solid red;line-height:20px; &#125; span&#123; line-height:40px;/*可以在浏览器中取消一下，观察一下位置变动*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;span&gt;文本内容1&lt;/span&gt;匿名文本内容&lt;em&gt;文本内容2&lt;/em&gt; &lt;img&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1.3对齐延伸问题：什么是替换元素。替换元素是指元素的内容本身并非文档直接表现的，换句话说，就是不同的页面中，浏览器不能确定其具体内容的元素，比如图片，按钮，因为图片的内容取决于图片引用的src属性源，按钮的类型则依据于其input类型，因此浏览器是不能确定今天img元素里面是一张美女图片，那么明天加载的页面里面img是不是一张美女图片。 除了替换元素，其他的元素就是非替换元素。非替换元素和替换元素在行框中的影响，主要是其高度计算方式，替换元素在行框中的位置是由其height，padding和border来决定，而非替换元素在行框中的位置则是其line-height和字体样式。 1.4对齐延伸问题：图片等替换元素在行框中有什么影响。如果只有文本元素的话，那么行框是很好计算基线位置的，但是如果有图片按钮等替换元素的话，那么计算方式就会变的稍微复杂一些。 在css中，有两种高度方式，一种是height，一种是line-height，这两种会决定元素的高度和位置，对于图片等行内替换元素来说，height是行框计算的依据，line-height对图片、按钮不会产生影响。 因此，如果有图片在行内的话，那么图片的底端会对齐文本的基线。 那么，如果图片的高度高于其他行内框的整体高度，这个时候会发生什么呢? 图片会在对齐原来的行框文本基线的基础上，撑开高度，使行框最高点刚好包括图片的顶端。 因此，当p段落里面的line-height都是40px的时候，加入图片之后，行框的高度就会比没有加入图片之前多50px - 40px=10px高度，因此基线就会下移10px的高度。 123&lt;p style=”line-height:40px;”&gt; &lt;span&gt;文本内容1&lt;/span&gt; &lt;em&gt;文本内容2&lt;/em&gt; &lt;img src=&quot;img/img2.png&quot; height=&quot;50px&quot; width=&quot;50px&quot; alt=&quot;高度图片&quot;&gt;&lt;/p&gt; 1.5对齐延伸问题：浮动对行内元素产生了什么样的影响。设置一个元素的浮动之后，元素会从正常的文档流中去除，但是同时也会对原来的文档流产生一些影响。 可以设想一下，在长方形区域的水面上，有很多人都想要有一个固定位置的水床（浏览器盒模型布局），但是固定水床需要登记（告诉浏览器的如何布局计算）。突然有一天，有一个人想要在长方形区域的最左侧建一个水床（设置元素左浮动），它悄悄地从水底移动到最左侧，把原先的水床挤走（浮动元素会尽可能移动在到容器最高处，及最左处或最右处），在最左侧那里建了一所水床，没有登记（没有告知父容器高度，因此产生高度塌陷）。其他的人不知道，在去最左端的固定水床的时候，发现已经有人固定了，因此只能固定在它旁边（浮动会产生环绕效果，而这一点就是因为浮动元素从正常文档流中去除掉的原因）。 图片是属于替换元素，在行框中的计算中，是依据于图片的高度，如果图片进行浮动的话，对于行框来说，图片不存在了，因此，行框还是依据原来的文本行基线来计算基线，进行对齐。 因此，效果如下 123&lt;p style=”line-height:40px;”&gt; &lt;span&gt;文本内容1&lt;/span&gt; &lt;em&gt;文本内容2&lt;/em&gt; &lt;img src=&quot;img/img2.png&quot; height=&quot;100px&quot; width=&quot;100px&quot; alt=&quot;高度图片&quot;&gt;&lt;/p&gt; 图片没有浮动： 图片左浮动： 没有图片: 2.对齐的过程行内元素是默认设置的vertical-align为baseline，也就是基线对齐。当一个文本行开始渲染的时候， 1.首先浏览器会找出每一个元素的类型，是替换元素还是非替换元素 2.然后根据它们的height或者line-height以及字体大小来生成每个元素行内框 3.确定行内框基线位置，确定行框基线位置 4.根据每个元素是否设置vertical-align来进行对齐。 3.关于居中对齐vertical-align：middle是将元素行内框的中点与父元素基线上方0.5ex处的一个点对齐，这里的1ex相对于元素的font-size来计算x字母的高度，1ex等于该字体下x的字母高度。 多数浏览器会将1ex处理为0.5em，也就是0.5倍字体大小font-size。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Express 的安装]]></title>
      <url>%2F2016%2F11%2F21%2Fexpress%2F</url>
      <content type="text"><![CDATA[Express 是基于 Node.js 平台，快速、开放、极简的 web 开发框架。安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 $ mkdir myapp $ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling。 $ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受默认设置即可，下面这个除外： $ entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。接下来安装 Express 并将其保存到依赖列表中： $ npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 –save 参数即可： $ npm install express 安装 Node 模块时，如果指定了 –save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js数组的基本用法]]></title>
      <url>%2F2016%2F11%2F20%2FJsArr%2F</url>
      <content type="text"><![CDATA[js数组的用法包括创建、取值赋值、添加以及根据下标(数值或字符)移除元素等等，在本文将为大家详细介绍下，感兴趣的朋友可以参考下1、创建数组123var array = new Array(); var array = new Array(size);//指定数组的长度 var array = new Array(item1,item2……itemN);//创建数组并赋值 2、取值、赋值12var item = array[index];//获取指定元素的值 array[index] = value;//为指定元素赋值 3、添加新元素123array.push(item1,item2……itemN);//将一个或多个元素加入数组，返回新数组的长度 array.unshift(item1,item2……itemN);//将一个或多个元素加入到数组的开始位置，原有元素位置自动后移，返回 新数组的长度 array.splice(start,delCount,item1,item2……itemN);//从start的位置开始向后删除delCount个元素，然后从start的位置开始插入一个或多个新元素 4、删除元素123array.pop();//删除最后一个元素，并返回该元素 array.shift();//删除第一个元素，数组元素位置自动前移，返回被删除的元素 array.splice(start,delCount);//从start的位置开始向后删除delCount个元素 5、数组的合并、截取12array.slice(start,end);//以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素 array.concat(array1,array2);//将多个数组拼接成一个数组 6、数组的排序12array.reverse();//数组反转 array.sort();//数组排序，返回数组地址 7、数组转字符串1array.join(separator);//将数组原因用separator连接起来 其次，数值型的直接传递数值的参数即可。例如var arr = [“aa”,”bb”];arr.del(0);下面说一下字符型的下标 12var arr = []. arr[&quot;aa&quot;] = 1;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中关于时间的处理]]></title>
      <url>%2F2016%2F11%2F19%2Ftime%2F</url>
      <content type="text"><![CDATA[关于时间的处理计算机处理时间一直都是以时间戳的方式进行的, 并且以格林尼治时间 1970/1/1 0:0:0开始计算的: 一、JS中Date对象常用的方法123456789101112131415161718192021222324252627var myDate = new Date();myDate.getYear(); //获取当前年份(2位)myDate.getFullYear(); //获取完整的年份(4位,1970-????)myDate.getMonth(); //获取当前月份(0-11,0代表1月)myDate.getDate(); //获取当前日(1-31)myDate.getDay(); //获取当前星期X(0-6,0代表星期天)myDate.getTime(); //获取当前时间(从1970.1.1开始的毫秒数)myDate.getHours(); //获取当前小时数(0-23)myDate.getMinutes(); //获取当前分钟数(0-59)myDate.getSeconds(); //获取当前秒数(0-59)myDate.getMilliseconds(); //获取当前毫秒数(0-999)myDate.toLocaleDateString(); //获取当前日期var mytime=myDate.toLocaleTimeString(); //获取当前时间myDate.toLocaleString( ); //获取日期与时间 二、js时间日期处理实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 增加天 function AddDays(date,value) &#123; date.setDate(date.getDate()+value); &#125; // 增加月 function AddMonths(date,value) &#123; date.setMonth(date.getMonth()+value); &#125; // 增加年 function AddYears(date,value) &#123; date.setFullYear(date.getFullYear()+value); &#125; // 是否为今天 function IsToday(date) &#123; return IsDateEquals(date,new Date()); &#125; // 是否为当月 function IsThisMonth(date) &#123; return IsMonthEquals(date,new Date()); &#125; // 两个日期的年是否相等 function IsMonthEquals(date1,date2) &#123; return date1.getMonth()==date2.getMonth()&amp;&amp;date1.getFullYear()==date2.getFullYear(); &#125; // 判断日期是否相等 function IsDateEquals(date1,date2) &#123; return date1.getDate()==date2.getDate()&amp;&amp;IsMonthEquals(date1,date2); &#125; // 返回某个日期对应的月份的天数 function GetMonthDayCount(date) &#123; switch(date.getMonth()+1) &#123; case 1:case 3:case 5:case 7:case 8:case 10:case 12: return 31; case 4:case 6:case 9:case 11: return 30; &#125; //二月份 date=new Date(date); var lastd=28; date.setDate(29); while(date.getMonth()==1) &#123; lastd++; AddDays(date,1); &#125; return lastd; &#125; // 返回两位数的年份 function GetHarfYear(date) &#123; var v=date.getYear(); if(v&gt;9)return v.toString(); return &quot;0&quot;+v; &#125; // 返回月份（修正为两位数） function GetFullMonth(date) &#123; var v=date.getMonth()+1; if(v&gt;9)return v.toString(); return &quot;0&quot;+v; &#125; // 返回日 （修正为两位数） function GetFullDate(date) &#123; var v=date.getDate(); if(v&gt;9)return v.toString(); return &quot;0&quot;+v; &#125; // 替换字符串 function Replace(str,from,to) &#123; return str.split(from).join(to); &#125; // 格式化日期的表示 function FormatDate(date,str) &#123; str=Replace(str,&quot;yyyy&quot;,date.getFullYear()); str=Replace(str,&quot;MM&quot;,GetFullMonth(date)); str=Replace(str,&quot;dd&quot;,GetFullDate(date)); str=Replace(str,&quot;yy&quot;,GetHarfYear(date)); str=Replace(str,&quot;M&quot;,date.getMonth()+1); str=Replace(str,&quot;d&quot;,date.getDate()); return str; &#125; 判断是否是闰年123function isLeapYear(year)&#123; return (year % 4 == 0) &amp;&amp; (year % 100 != 0 || year % 400 == 0); &#125; js时间差函数123456789101112131415161718192021222324function addDay(days,n) &#123; //函数说明：days日期差，n代表如下含义。 var my_date_ago=new Date(new Date() - days * 24 * 60 * 60 * 1000 * -1);//days天的日期 switch (n) &#123; case 1: //返回年 return(my_date_ago.getFullYear()); break; case 2: //返回月 return(my_date_ago.getMonth()+1); break; case 3: //返回日 return(my_date_ago.getDate()); break; default : //返回全部 return(my_date_ago.getFullYear() + &quot;-&quot; + (my_date_ago.getMonth()+1) + &quot;-&quot; + my_date_ago.getDate()); break; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS的垂直居中和水平居中总结]]></title>
      <url>%2F2016%2F11%2F18%2Fcenter%2F</url>
      <content type="text"><![CDATA[CSS的垂直居中和水平居中总结前言CSS居中一直是一个比较敏感的话题，为了以后开发的方便，楼主觉得确实需要总结一下了，总的来说，居中问题分为垂直居中和水平居中，实际上水平居中是很简单的，但垂直居中的方式和方法就千奇百怪了。 内联元素居中方案水平居中设置： 1.行内元素 设置 text-align:center； 2.Flex布局 设置display:flex;justify-content:center;(灵活运用) 垂直居中设置： 1.父元素高度确定的单行文本（内联元素） 设置 height = line-height； 2.父元素高度确定的多行文本（内联元素） a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle； b:先设置 display:table-cell 再设置 vertical-align:middle； 块级元素居中方案水平居中设置： 1.定宽块状元素 设置 左右 margin 值为 auto； 2.不定宽块状元素 a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto； b:给该元素设置 display:inine 方法； c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%； 垂直居中设置： 1.使用position:absolute（fixed）,设置left、top、margin-left、margin-top的属性; 1234567.box&#123; position:absolute;/*或fixed*/ top:50%; left:50%; margin-top:-100px; margin-left:-200px;&#125; 2.利用position:fixed（absolute）属性，margin:auto这个必须不要忘记了; 12345678.box&#123; position: absolute;或fixed top:0; right:0; bottom:0; left:0; margin: auto;&#125; 3.利用display:table-cell属性使内容垂直居中; 12345678.box&#123; display:table-cell; vertical-align:middle; text-align:center; width:120px; height:120px; background:purple;&#125; 4.使用css3的新属性transform:translate(x,y)属性; 1234567.box&#123; position: absolute; transform: translate(50%,50%); -webkit-transform:translate(50%,50%); -moz-transform:translate(50%,50%); -ms-transform:translate(50%,50%);&#125; 5.最高大上的一种，使用:before元素; 12345678910111213141516.box&#123; position:fixed; display:block; background:rgba(0,0,0,.5);&#125;.box:before&#123; content:&apos;&apos;; display:inline-block; vertical-align:middle; height:100%;&#125;.box.content&#123; width:60px; height:60px; line-height:60px; color:red; 6.Flex布局; 12345678910111213141516171819202122.box&#123; display: -webkit-box; display: -webkit-flex; display: -moz-box; display: -moz-flex; display: -ms-flexbox; display: flex; 水平居中 -webkit-box-align: center; -moz-box-align: center; -ms-flex-pack:center; -webkit-justify-content: center; -moz-justify-content: center; justify-content: center; 垂直居中 -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-align:center; -webkit-align-items: center; -moz-align-items: center; align-items: center;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS清除浮动方法总结]]></title>
      <url>%2F2016%2F11%2F18%2Fremove-float%2F</url>
      <content type="text"><![CDATA[CSS清除浮动方法总结总括：详细总结了CSS中清楚浮动的几种方法。 什么是CSS清除浮动？在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。 引用W3C的例子，news容器没有包围浮动的元素。1234567891011121314.news &#123; background-color: gray; border: solid 1px black;&#125;.news img &#123; float: left;&#125;.news p &#123; float: right;&#125;&lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 清除浮动方法方法一：使用带clear属性的空元素在浮动元素后使用一个空元素如 &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; ，并在CSS中赋予 .clear{clear:both;} 属性即可清理浮动。亦可使用 &lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt; 来进行清理。 123456789101112131415161718.news &#123; background-color: gray; border: solid 1px black;&#125;.news img &#123; float: left;&#125;.news p &#123; float: right;&#125;.clear &#123; clear: both;&#125;&lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 优点：简单，代码少，浏览器兼容性好。 缺点：需要添加大量无语义的html元素，代码不够优雅，后期不容易维护。 方法二：使用CSS的overflow属性给浮动元素的容器添加 overflow:hidden; 或 overflow:auto; 可以清除浮动，另外在 IE6 中还需要触发hasLayout，例如为父元素设置容器宽高或设置zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 12345678910111213141516.news &#123; background-color: gray; border: solid 1px black; overflow: hidden; *zoom: 1;&#125;.news img &#123; float: left;&#125;.news p &#123; float: right;&#125;&lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 方法三：给浮动的元素的容器添加浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理什么都不做，给浮动元素后面的元素添加clear属性。 123456789101112131415161718.news &#123; background-color: gray; border: solid 1px black;&#125;.news img &#123; float: left;&#125;.news p &#123; float: right;&#125;.content&#123; clear:both;&#125;&lt;div class=&quot;news&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt; &lt;div class=&quot;content&quot;&gt;***&lt;/div&gt;&lt;/div&gt; 注意这里的div.content有内容。 方法五：使用CSS的:after伪元素结合:after伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 12345678910111213141516171819202122232425.news &#123; background-color: gray; border: solid 1px black;&#125;.news img &#123; float: left;&#125;.news p &#123; float: right;&#125;.clearfix:after&#123; content: &quot;020&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125;.clearfix &#123;/* 触发 hasLayout */ zoom: 1;&#125;&lt;div class=&quot;news clearfix&quot;&gt; &lt;img src=&quot;news-pic.jpg&quot; /&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt; 通过CSS伪元素在容器的内部元素最后添加了一个看不见的空格”020”或点”.”，并且赋予clear属性来清除浮动。需要注意的是为了IE6和IE7浏览器，要给clearfix这个class添加一条zoom:1;触发haslayout。 总结通过上面的例子，我们不难发现清除浮动的方法可以分成两类： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。 二是触发浮动元素父元素的 BFC (Block Formatting Contexts, 块级格式化上下文)，使到该父元素可以包含浮动元素，关于这一点。 在网页主要布局时使用:after伪元素方法并作为主要清理浮动方式；在小模块如ul里使用overflow:hidden;（留意可能产生的隐藏溢出元素问题）；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。 最后可以使用相对完美的:after伪元素方法清理浮动，文档结构更加清晰。这也是比较常用的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactNative准备:环境的创建和应用]]></title>
      <url>%2F2016%2F11%2F17%2Freact-native%2F</url>
      <content type="text"><![CDATA[配置相关环境,点击下面两个网址,打开终端,按要求安装要下面4个环境:官网:https://facebook.github.io/react-native/docs/getting-started.html#content 中文网:http://reactnative.cn/docs/0.24/getting-started.html#content 这里仅列出了OS X操作系统的环境安装, window的可以自己查看上面给出网址里有. 重要安装命令如下: 1.安装homebrew，在终端输入：/usr/bin/ruby -e &quot;$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.安装watchman：(监测文件变化的工具)brew install --HEAD watchman 3.安装node：brew install node 4.安装flow：（监测CSS语法的工具）brew install flow 之后是安装ReactNative: 5.安装ReactNative：npm install -g react-native-cli 6.初始化应用：react-native init ReactNative_1 (你需要的工程名) 7.运行应用：(这里假设你已安装了Xcode,有simulator虚拟机)react-native run-ios 到此环境已经搭建完毕,可以运行ReactNative程序了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-native-icons的简单使用]]></title>
      <url>%2F2016%2F11%2F17%2Freact-native-icons%2F</url>
      <content type="text"><![CDATA[react-native-vector-icons的简单使用,图片,按钮,标签视图,导航条icons是可以直接使用图片名, 就能加载图片的三方,使用很方便, 你不需要在工程文件夹里塞各种图片, 节省很多空间,下面就来看看怎么使用吧! 1.首先打开终端进入到我们的工程文件夹下输入npm install react-native-vector-icons --save (回车) npm install rnpm -g rnpm link (回车) 2. 在Finder中用Xcode打开工程: …/Demo/ios/Demo.xcodeproj(1).右键工程文件Add Files to “(你工程名)”(2).选择node_modules/react-native-vector-icons/Fonts文件(3).点击”完成”. 3. 在xcode的Info.plist文件中,加入: Fonts provided by application数组,并加入以下9项: 到此环境就算设置好了, 接下来就是使用ICONS了. 4. 在Finder中右键用Atom打开工程: 5.然后就开始编辑我们的程序了:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&apos;use strict&apos;;import React, &#123; AppRegistry, Component, View, StyleSheet, AlertIOS, Text, TabBarIOS, NavigatorIOS,&#125; from &apos;react-native&apos;;var Icon = require(&apos;react-native-vector-icons/FontAwesome&apos;);import FindComponent from &apos;./FindComponent&apos;;import SearchComponent from &apos;./SearchComponent&apos;;class Demo extends Component &#123; state = &#123; selectedTab: &apos;find&apos;, &#125;; loginWithFacebook = () =&gt; &#123; //点击&quot;Login with Facebook&quot;按钮后触发的方法 AlertIOS.alert(&quot;facebook&quot;); &#125; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Icon name=&quot;rocket&quot; //图片名连接,可以到这个网址搜索:http://ionicons.com/, 使用时:去掉前面的 &quot;icon-&quot; !!!! size=&#123;30&#125; //图片大小 color=&quot;red&quot; //图片颜色 /&gt; &lt;Icon.Button //在图片后加文字 name=&quot;facebook&quot; backgroundColor=&quot;#3b5998&quot; onPress=&#123;this.loginWithFacebook&#125; //点击该按钮后触发的方法 &gt; Login with Facebook &lt;/Icon.Button&gt; &lt;Icon.Button //在图片后加, 自定义样式的文字 name=&quot;facebook&quot; backgroundColor=&quot;#3b5998&quot;&gt; &lt;Text style=&#123;&#123;fontFamily: &apos;Arial&apos;, fontSize: 15&#125;&#125;&gt;Login with Facebook&lt;/Text&gt; &lt;/Icon.Button&gt; &lt;TabBarIOS //和标签视图一起使用 tintColor=&quot;#4977f0&quot; barTintColor=&quot;#E6E6E6&quot;&gt; &lt;Icon.TabBarItem //用 Icon.TabBarItem 代替 TabBarIOS.Item title=&quot;发现&quot; iconName=&quot;home&quot; selectedIconName=&quot;home&quot; selected = &#123;this.state.selectedTab === &apos;find&apos;&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; selectedTab: &apos;find&apos;, &#125;); &#125;&#125; &gt; &lt;NavigatorIOS //导航栏 style=&#123;styles.container&#125; tintColor=&apos;#FFFFFF&apos; barTintColor=&apos;#4977f0&apos; initialRoute=&#123;&#123; title: &quot;发现&quot;, titleTextColor: &apos;white&apos;, component: FindComponent &#125;&#125; /&gt; &lt;/Icon.TabBarItem&gt; &lt;Icon.TabBarItem //用 Icon.TabBarItem 代替 TabBarIOS.Item title=&quot;搜索&quot; iconName=&quot;search&quot; selectedIconName=&quot;search&quot; selected = &#123;this.state.selectedTab === &apos;search&apos;&#125; onPress=&#123;() =&gt; &#123; this.setState(&#123; selectedTab: &apos;search&apos;, &#125;); &#125;&#125; &gt; &lt;NavigatorIOS style=&#123;styles.container&#125; tintColor=&apos;#FFFFFF&apos; barTintColor=&apos;#4977f0&apos; initialRoute=&#123;&#123; title: &quot;搜索&quot;, titleTextColor: &apos;white&apos;, component: SearchComponent &#125;&#125; /&gt; &lt;/Icon.TabBarItem&gt; &lt;/TabBarIOS&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: &apos;center&apos;, &#125;,&#125;);AppRegistry.registerComponent(&apos;Demo&apos;, () =&gt; Demo); 在terminal中的工程文件夹下,输入react-native run-ios(回车)等待程序运行起来就能看到效果啦. 主要代码下载地址: http://download.csdn.net/detail/margaret_mo/9512769 参考网站: https://github.com/oblador/react-native-vector-icons]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp的简易安装流程]]></title>
      <url>%2F2016%2F11%2F16%2Fgulp%2F</url>
      <content type="text"><![CDATA[安裝gulp1.安装 nodenode下载地址：http://nodejs.cn/download/ 安装比较简单，基本一直下一步即可，安装路径随意。安装完成后，终端输入如下命令 显示版本号即安装成功。 node -v 2.全局安装gulp执行 npm install gulp -g 检测gulp是否安装成功执行 gulp -v 显示版本号即安装成功 3.项目文件根目录新建package.json注：package.json是基于nodejs项目必不可少的配置文件，它是存放在项目根目录的普通json文件重点内容 1.先创建一个项目文件夹 2.进入项目文件夹中 3.运行 npm init 产出 package.json 的文件 4.检测package.json是否成功新建 查看项目文件根目录，是否新建package.json 本地安装gulp插件注：全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能进入你的项目文件路径中后，执行 npm install gulp --save-dev 安装插件安装 gulp-jade 和 gulp-sass （拿该插件进行示例） npm install gulp-jade gulp-sass 新建gulpfile.js注：gulpfile.js是gulp的配置文件，放于根目录中 在gulpfile.js 引入插件 1234// 引入你所需要用到的插件 require(&quot;引入的插件名称&quot;);var jade = require(&quot;gulp-jade&quot;);var sass = require(&quot;gulp-sass&quot;);var gulp = require(&quot;gulp&quot;); 定制任务 创建sass文件目录 123456789101112131415// 写任务 默认任务名 defaultgulp.task(&quot;sass&quot;,function()&#123; gulp.src(&quot;sass/*.scss&quot;) //获取该任务需要的文件 .pipe(sass()) //该任务调用的模块 .pipe(gulp.dest(&quot;css/&quot;)) //将在css文件夹中生成css文件&#125;);// 默认任务gulp.task(&quot;default&quot;,[&quot;sass&quot;,&quot;watch&quot;]);//监听文件gulp.task(&quot;watch&quot;,function()&#123; gulp.watch(&quot;sass/*.scss&quot;,[&quot;sass&quot;]) //监听sass文件里所有以‘*.scss’结尾的文件，修改时自动执行 sass 任务。&#125;); 运行 gulp执行 gulp 任务名称 运行该任务 示例：gulp sass 执行gulpfile.js中的sass任务 执行 gulp 调用default中的所有任务 常用插件sass的编译 (gulp-sass) less编译 （gulp-less） 重命名（gulp-rename） 自动添加css前缀（gulp-autoprefixer） 压缩css（gulp-clean-css） js代码校验（gulp-jshint） 合并js文件（gulp-concat） 压缩js代码（gulp-uglify） 压缩图片（gulp-imagemin） 自动刷新页面（gulp-livereload，谷歌浏览器亲测，谷歌浏览器需安装livereload插件） 图片缓存，只有图片替换了才压缩（gulp-cache） 更改提醒（gulp-notify）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo,搭建属于自己的博客]]></title>
      <url>%2F2016%2F11%2F14%2Fhexo%2F</url>
      <content type="text"><![CDATA[正文：hexo是一款基于Node.js的静态博客框架，由于原文讲到的hexo是以前的老版本，所以现在的版本配置的时候会有些改动。 配置环境：安装Node （必须） 作用：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。 安装Git（必须） 作用：把本地的hexo内容提交到github上去。 安装Xcode就自带有Git，我就不多说了。 申请GitHub（必须） 作用：是用来做博客的远程创库、域名、服务器之类的，怎么与本地hexo建立连接等下讲。 github账号我也不再啰嗦了,没有的话直接申请就行了，跟一般的注册账号差不多，SSH Keys，看你自己了，可以不配制，不配置的话以后每次对自己的博客有改动提交的时候就要手动输入账号密码，配置了就不需要了，怎么配置我就不多说了，网上有很多教程。 正式安装HexoNode和Git都安装好后,首先创建一个文件夹,如blog,用户存放hexo的配置文件,然后进入blog里安装Hexo。 执行如下命令安装Hexo： sudo npm install -g hexo 初始化然后，执行init命令初始化hexo,命令： hexo init 好啦，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 hexo generate（hexo g也可以） 本地启动 启动本地服务，进行文章预览调试，命令： hexo server 浏览器输入http://localhost:4000 我不知道你们能不能，反正我不能，因为我还有环境没配置好 配置Github建立Repository 建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】，固定写法 然后建立关联，我的blog在本地/Users/leopard/blog，blog是我之前建的东西也全在这里面，有： _config.yml node_modules public source **db.json** **package.json** **scaffolds** **themes** 现在我们需要_config.yml文件，来建立关联，命令： vim _config.yml 翻到最下面，改成我这样子的 deploy: type: git repository: https://github.com/xxxxxx/xxxxxx.github.io.git (xxxxxx改为你的github用户名) branch: master 然后执行命令： npm install hexo-deployer-git –save 网上会有很多说法，有的type是github, 还有repository最后面的后缀也不一样，是github.com.git，我也踩了很多坑，我现在的版本是hexo: 3.1.1，执行命令hexo -vsersion就出来了,貌似3.0后全部改成我上面这种格式了。 忘了说了，我没用SSH Keys如果你用了SSH Keys的话直接在github里复制SSH的就行了，总共就两种协议，相信你懂的。 然后，执行配置命令： hexo deploy 然后再浏览器中输入http://xxxxxx.github.io/ 就行了，把这里的‘xxxxxx’改成你github的账户名就行了部署步骤 每次部署的步骤，可按以下三步来进行。 **hexo clean** **hexo generate** **hexo deploy** 一些常用命令： hexo new”postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 报错总结ERROR Deployer not found: git 或者 ERROR Deployer not found: github 解决方法： npm install hexo-deployer-git –save 如发生报错： ERROR Process failed: layout/.DS_Store , 那么进入主题里面layout和_partial目录下，使用删除命令： rm-rf.DS_Store ERROR Plugin load failed: hexo-server 原因： Besides,utilities are separated into a standalone module.hexo.util is not reachable anymore. 解决方法，执行命令： sudo npm install hexo-server 执行命令hexo server，提示：Usage: hexo …. 原因： 我认为是没有生成本地服务 解决方法，执行命令： npm install hexo-server –save 提示：hexo-server@0.1.2 node_modules/hexo-server …. 表示成功了参考 这个时候再执行： hexo-server 得到: INFOHexois running at http://127.0.0.1:4000/.PressCtrl+C to stop. 这个时候再点击http://127.0.0.1:4000，正常情况下应该是最原始的画面，如果你看到的是： 白板和Cannot GET / 几个字 原因： 由于2.6以后就更新了，我们需要手动配置些东西，我们需要输入下面三行命令： npm install hexo-renderer-ejs –save npm install hexo-renderer-stylus –save npm install hexo-renderer-marked –save 这个时候再重新生成静态文件，命令： hexo generate（或hexo g） 启动本地服务器： hexo server（或hexo s） 再，点击网址http://127.0.0.1:4000OK终于可以看到属于你自己的blog啦，😄，虽然很简陋，但好歹有了一个属于自己的小窝了。参考链接，本地已经简单的设置好了，但是现在域名和服务器都是基于自己的电脑，接下来需要跟github进行关联。 主题推荐这里有大量的主题列表使用方法里面 都有详细的介绍，我就不多说了。 我这里有几款个人认为不错的主题，免去你们，一个一个的选了，欢迎吐槽我的审美，😄 Cover- A chic theme with facebook-like cover photo Oishi- A white theme based on Landscape plus and Writing. Sidebar- Another theme based on Light with a simple sidebar TKL- A responsive design theme for Hexo. 一个设计优雅的响应式主题 Tinnypp- A clean, simple theme based on Tinny Writing- A small and simple hexo theme based on Light Yilia- Responsive and simple style 优雅简洁响应式主题，我用得就是这个。 Pacman voidy- A theme with dynamic tagcloud and dynamic snow 一些基本路径文章在source/_posts, 文章支持Markdown语法，可以使用一些MarkDown渲染工具。如果想修改头像可以直接在主题的_config.yml文件里面修改，友情链接，之类的都在这里。开始打理你的博客吧，有什么问题或者建议，都可以提出来，我会继续完善的。 ###修改头像我当前的路径/Users/leopard/blog/themes/yilia，ls 你可以看到 Gruntfile.js _config.yml package.json README.md layout source vim _config.yml 进去，找到 #你的头像url avatar: 后接一个URL就行了，头像就修改成功了 部署 hexo g 提交 hexo d ###Markdown语法参考链接 链接 转载自 潘柏信的博客：http://leopardpan.github.io,搭建属于自己的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mou 书写格式]]></title>
      <url>%2F2016%2F11%2F14%2Fmou%2F</url>
      <content type="text"><![CDATA[Mou OverviewMou, the missing Markdown editor for web developers. SyntaxStrong and Emphasizestrong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and EmailAn email &#101;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#x6c;&#101;&#x2e;&#x63;&#x6f;&#109; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. ImagesAn inline image , title is optional. A reference style image. Inline code and Block codeInline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered ListsOrdered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered ListsUnordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. Horizontal RulesThree or more asterisks or dashes: HeadersSetext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6Extra SyntaxFootnotesFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[^1] [^1]: And that’s the footnote. StrikethroughWrap with 2 tilde characters: Strikethrough Fenced Code BlocksStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. TablesA simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right ShortcutsView Toggle live preview: Shift + Cmd + I Toggle Words Counter: Shift + Cmd + W Toggle Transparent: Shift + Cmd + T Toggle Floating: Shift + Cmd + F Left/Right = 1/1: Cmd + 0 Left/Right = 3/1: Cmd + + Left/Right = 1/3: Cmd + - Toggle Writing orientation: Cmd + L Toggle fullscreen: Control + Cmd + F Actions Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + / Hard Linebreak: Control + Return Edit Auto complete current word: Esc Find: Cmd + F Close find bar: Esc Post Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T Export Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P And more?Don’t forget to check Preferences, lots of useful options are there. Follow @Mou on Twitter for the latest news. For feedback, use the menu Help - Send Feedback]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
